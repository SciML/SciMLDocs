<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Getting Started with Julia&#39;s SciML for the C++/Fortran User · Overview of Julia&#39;s SciML</title><meta name="title" content="Getting Started with Julia&#39;s SciML for the C++/Fortran User · Overview of Julia&#39;s SciML"/><meta property="og:title" content="Getting Started with Julia&#39;s SciML for the C++/Fortran User · Overview of Julia&#39;s SciML"/><meta property="twitter:title" content="Getting Started with Julia&#39;s SciML for the C++/Fortran User · Overview of Julia&#39;s SciML"/><meta name="description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="twitter:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:url" content="https://docs.sciml.ai/stable/comparisons/cppfortran/"/><meta property="twitter:url" content="https://docs.sciml.ai/stable/comparisons/cppfortran/"/><link rel="canonical" href="https://docs.sciml.ai/stable/comparisons/cppfortran/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/installation/">Installing SciML Software</a></li><li><a class="tocitem" href="../../getting_started/first_simulation/">Build and run your first simulation with Julia&#39;s SciML</a></li><li><a class="tocitem" href="../../getting_started/first_optimization/">Solve your first optimization problem</a></li><li><a class="tocitem" href="../../getting_started/fit_simulation/">Fit a simulation to a dataset</a></li><li><a class="tocitem" href="../../getting_started/find_root/">Find the root of an equation (i.e. solve f(u)=0)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox" checked/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../matlab/">Getting Started with  Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li class="is-active"><a class="tocitem" href>Getting Started with Julia&#39;s SciML for the C++/Fortran User</a><ul class="internal"><li><a class="tocitem" href="#Why-SciML?-High-Level-Workflow-Reasons"><span>Why SciML? High-Level Workflow Reasons</span></a></li><li><a class="tocitem" href="#Why-SciML?-Some-Technical-Details"><span>Why SciML? Some Technical Details</span></a></li></ul></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../../showcase/showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/missing_physics/">Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a></li><li><a class="tocitem" href="../../showcase/bayesian_neural_ode/">Uncertainty Quantified Deep Bayesian Model Discovery</a></li><li><a class="tocitem" href="../../showcase/optimal_data_gathering_for_missing_physics/">Optimal Data Gathering for Missing Physics</a></li><li><a class="tocitem" href="../../showcase/blackhole/">Discovering the Relativistic Corrections to Binary Black Hole Dynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li><a class="tocitem" href="../../showcase/pinngpu/">GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li><li><a class="tocitem" href="../../showcase/massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li><li><a class="tocitem" href="../../showcase/gpu_spde/">GPU-Accelerated Stochastic Partial Differential Equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/ode_types/">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li><li><a class="tocitem" href="../../showcase/symbolic_analysis/">Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li><li><a class="tocitem" href="../../showcase/optimization_under_uncertainty/">Optimization Under Uncertainty</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/equation_solvers/">Equation Solvers</a></li><li><a class="tocitem" href="../../highlevels/inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li><li><a class="tocitem" href="../../highlevels/partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../../highlevels/model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../../highlevels/symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../../highlevels/array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../../highlevels/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../highlevels/plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../../highlevels/implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../../highlevels/symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../../highlevels/interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../../highlevels/developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li><a class="is-disabled">Comparison With Other Tools</a></li><li class="is-active"><a href>Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/comparisons/cppfortran.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="cppfortran"><a class="docs-heading-anchor" href="#cppfortran">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a><a id="cppfortran-1"></a><a class="docs-heading-anchor-permalink" href="#cppfortran" title="Permalink"></a></h1><p>You don&#39;t need help if you&#39;re a Fortran guru. I&#39;m just kidding, you&#39;re not a Lisp developer. If you&#39;re coming from C++ or Fortran, you may be familiar with high-performance computing environments similar to SciML, such as <a href="https://petsc.org/release/">PETSc</a>, <a href="https://trilinos.github.io/">Trilinos</a>, or <a href="https://computing.llnl.gov/projects/sundials">Sundials</a>. The following are some points to help the transition.</p><h2 id="Why-SciML?-High-Level-Workflow-Reasons"><a class="docs-heading-anchor" href="#Why-SciML?-High-Level-Workflow-Reasons">Why SciML? High-Level Workflow Reasons</a><a id="Why-SciML?-High-Level-Workflow-Reasons-1"></a><a class="docs-heading-anchor-permalink" href="#Why-SciML?-High-Level-Workflow-Reasons" title="Permalink"></a></h2><p>If you&#39;re coming from “hardcore” C++/Fortran computing environments, some things to check out with Julia&#39;s SciML are:</p><ul><li><strong>Interactivity</strong> - use the interactive REPL to easily investigate numerical details.</li><li><strong>Metaprogramming performance tools</strong> - tools like <a href="https://github.com/JuliaSIMD/LoopVectorization.jl">LoopVectorization.jl</a> can be used to generate faster code than even some of the most hand-optimized C++/Fortran code. Current benchmarks <a href="https://www.youtube.com/watch?v=KQ8nvlURX4M">show this SIMD-optimized Julia code outperforming OpenBLAS and MKL BLAS implementations in many performance regimes</a>.</li><li><strong>Symbolic modeling languages</strong> - writing models by hand can leave a lot of performance on the table. Using high-level modeling tools like <a href="https://github.com/SciML/ModelingToolkit.jl">ModelingToolkit</a> can automate symbolic simplifications, which <a href="https://www.youtube.com/watch?v=ZFoQihr3xLs">improve the stability and performance of numerical solvers</a>. On complex models, even the best handwritten C++/Fortran code is orders of magnitude behind the code that symbolic tearing algorithms can achieve!</li><li><strong>Composable Library Components</strong> - In C++/Fortran environments, every package feels like a silo. Arrays made for PETSc cannot easily be used in Trilinos, and converting Sundials NVector outputs to DataFrames for post-simulation data processing is a process itself. The Julia SciML environment embraces interoperability. Don&#39;t wait for SciML to do it: by using generic coding with JIT compilation, these connections create new optimized code on the fly and allow for a more expansive feature set than can ever be documented. Take <a href="https://github.com/JuliaArbTypes/ArbFloats.jl">new high-precision number types from a package</a> and stick them into a nonlinear solver. Take <a href="https://github.com/JuliaGPU/oneAPI.jl">a package for Intel GPU arrays</a> and stick it into the differential equation solver to use specialized hardware acceleration.</li><li><strong>Wrappers to the Libraries You Know and Trust</strong> - Moving to SciML does not have to be a quick transition. SciML has extensive wrappers to many widely-used classical solver environments such as <a href="https://github.com/SciML/Sundials.jl">SUNDIALS</a> and <a href="https://github.com/SciML/ODEInterfaceDiffEq.jl">Hairer&#39;s classic Fortran ODE solvers (dopri5, dop853, etc.)</a>. Using these wrapped solvers is painless and can be swapped in for the Julia versions with one line of code. This gives you a way to incrementally adopt new features/methods while retaining the older pieces you know and trust.</li><li><strong>Don&#39;t Start from Scratch</strong> - SciML builds on the extensive <a href="https://docs.julialang.org/en/v1/">Base library of Julia</a>, and thus grows and improves with every update to the language. With hundreds of monthly contributors to SciML and hundreds of monthly contributors to Julia, SciML is one of the most actively developed open-source scientific computing ecosystems out there!</li><li><strong>Easier High-Performance and Parallel Computing</strong> - With Julia&#39;s ecosystem, <a href="https://github.com/JuliaGPU/CUDA.jl">CUDA</a> will automatically install of the required binaries and <code>cu(A)*cu(B)</code> is then all that&#39;s required to GPU-accelerate large-scale linear algebra. <a href="https://github.com/JuliaParallel/MPI.jl">MPI</a> is easy to install and use. <a href="https://docs.julialang.org/en/v1/manual/distributed-computing/">Distributed computing through password-less SSH</a>. <a href="https://docs.julialang.org/en/v1/manual/multi-threading/">Multithreading</a> is automatic and baked into many libraries, with a specialized algorithm to ensure hierarchical usage does not oversubscribe threads. Basically, libraries give you a lot of parallelism for free, and doing the rest is a piece of cake.</li><li><strong>Mix Scientific Computing with Machine Learning</strong> - Want to <a href="https://arxiv.org/abs/2001.04385">automate the discovery of missing physical laws using neural networks embedded in differentiable simulations</a>? Julia&#39;s SciML is the ecosystem with the tooling to integrate machine learning into the traditional high-performance scientific computing domains, from multiphysics simulations to partial differential equations.</li></ul><p>In this plot, <code>Sundials</code>/<code>Hairer</code> in purple/red represent C++/Fortrans most commonly used solvers:</p><p><img src="https://user-images.githubusercontent.com/1814174/195836404-ea69730e-69a4-4bf0-8d12-f57d5b8fce21.PNG" alt/></p><h2 id="Why-SciML?-Some-Technical-Details"><a class="docs-heading-anchor" href="#Why-SciML?-Some-Technical-Details">Why SciML? Some Technical Details</a><a id="Why-SciML?-Some-Technical-Details-1"></a><a class="docs-heading-anchor-permalink" href="#Why-SciML?-Some-Technical-Details" title="Permalink"></a></h2><p>Let&#39;s face the facts, in the <a href="https://benchmarks.sciml.ai/stable/">open benchmarks</a> the pure-Julia solvers tend to outperform the classic “best” C++ and Fortran solvers in almost every example (with a few notable exceptions). But why?</p><p>The answer is two-fold: Julia is as fast as C++/Fortran, and the algorithms are what matter.</p><h3 id="Julia-is-as-Fast-as-C/Fortran"><a class="docs-heading-anchor" href="#Julia-is-as-Fast-as-C/Fortran">Julia is as Fast as C++/Fortran</a><a id="Julia-is-as-Fast-as-C/Fortran-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-is-as-Fast-as-C/Fortran" title="Permalink"></a></h3><p>While Julia code looks high level like Python or MATLAB, its performance is on par with C++ and Fortran. At a technical level, when Julia code is type-stable, i.e. that the types that are returned from a function are deducible at compile-time from the types that go into a function, then Julia can optimize it as much as C++ or Fortran by automatically devirtualizing all dynamic behavior and compile-time optimizing the quasi-static code. This is not an empirical statement, it&#39;s a <a href="https://arxiv.org/abs/2109.01950">provable type-theoretic result</a>. The resulting compiler used on the resulting quasi-static representation is <a href="https://llvm.org/">LLVM</a>, the same optimizing compiler used by <a href="https://clang.llvm.org/">clang</a> and <a href="https://lfortran.org/">LFortran</a>.</p><p>For more details on how Julia code is optimized and how to optimize your own Julia code, check out <a href="https://book.sciml.ai/notes/02-Optimizing_Serial_Code/">this chapter from the SciML Book</a>.</p><h3 id="SciML&#39;s-Julia-Algorithms-Have-Performance-Advantages-in-Many-Common-Regimes"><a class="docs-heading-anchor" href="#SciML&#39;s-Julia-Algorithms-Have-Performance-Advantages-in-Many-Common-Regimes">SciML&#39;s Julia Algorithms Have Performance Advantages in Many Common Regimes</a><a id="SciML&#39;s-Julia-Algorithms-Have-Performance-Advantages-in-Many-Common-Regimes-1"></a><a class="docs-heading-anchor-permalink" href="#SciML&#39;s-Julia-Algorithms-Have-Performance-Advantages-in-Many-Common-Regimes" title="Permalink"></a></h3><p>There are many ways which Julia&#39;s algorithms achieve performance advantages. Some facts to highlight include:</p><ul><li>Julia is at the forefront of numerical methods research in many domains. This is highlighted in <a href="https://www.stochasticlifestyle.com/comparison-differential-equation-solver-suites-matlab-r-julia-python-c-fortran/">the differential equation solver comparisons</a>, where the Julia solvers were the first to incorporate “newer” optimized Runge-Kutta tableaus, around half a decade before other software. Since then, the literature has only continued to evolve, and only Julia&#39;s SciML keeps up. At this point, many of the publication&#39;s first implementation is in <a href="https://github.com/SciML/OrdinaryDiffEq.jl">OrdinaryDiffEq.jl</a> with benchmark results run on the <a href="https://benchmarks.sciml.ai/stable/">SciML Open Benchmarking platform!</a></li><li>Julia does not take low-level mathematical functions for granted. The <a href="https://openlibm.org/">common openlibm implementation of mathematical functions</a> used in many open source projects is maintained by the Julia and SciML developers! However, in modern Julia, every function from   <code>log</code> to <code>^</code> has been reimplemented in the Julia standard library to improve numerical correctness and performance. For example, <a href="https://www.biorxiv.org/content/10.1101/2020.11.28.402297v2">Pumas, the nonlinear mixed effects estimation system</a> built on SciML, and <a href="https://www.youtube.com/watch?v=6wGSCD3cI9E">used by Moderna for the vaccine trials</a>, notes in its paper that approximations to such math libraries itself gave a 2x performance improvement in even the most simple non-stiff ODE solvers over matching Fortran implementations. Pure Julia linear algebra tooling, like <a href="https://github.com/JuliaLinearAlgebra/RecursiveFactorization.jl">RecursiveFactorization.jl for LU-factorization</a>, outperforms common LU-factorization implementations used in open-source projects like OpenBLAS by around 5x! This should not be surprising though, given that OpenBLAS was a prior <a href="https://julia.mit.edu/">MIT Julia Lab</a> project!</li><li>Compilers are limited on the transformations that they can perform because they do not have high-level context-dependent mathematical knowledge. Julia&#39;s SciML makes <a href="https://twitter.com/ChrisRackauckas/status/1477274812460449793">extensive use of customized symbolic-based compiler transformations</a> to improve performance with context-based code optimizations. Things like <a href="https://openreview.net/pdf?id=rJlPdcY38B">sparsity patterns are automatically deduced from code and optimized on</a>. <a href="https://www.youtube.com/watch?v=ZFoQihr3xLs">Nonlinear equations are symbolically-torn</a>, changing large nonlinear systems into sequential solving of much smaller systems and benefiting from an O(n^3) cost reduction. These can be orders of magnitude cost reductions which come for free, and unless you know every trick in the book it will be difficult to match SciML&#39;s performance!</li><li>Pervasive automatic differentiation mixed with compiler tricks wins battles. Many high-performance libraries in C++ and Fortran cannot assume that all of its code is compatible with automatic differentiation, and thus many internal performance tricks are not applied. For example, <a href="https://github.com/JuliaDiff/ForwardDiff.jl/blob/master/docs/src/dev/how_it_works.md">ForwardDiff.jl&#39;s chunk seeding</a> allows for a single call to <code>f</code> to generate multiple columns of a Jacobian. When mixed with <a href="https://github.com/JuliaDiff/SparseDiffTools.jl">sparse coloring tools</a>, entire Jacobians can be constructed with just a few <code>f</code> calls. Studies in applications have <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1009598">shown this greatly outperforms finite differencing, especially when Julia&#39;s implicit multithreading is used</a>.</li></ul><h3 id="Let&#39;s-Dig-Deep-Into-One-Case:-Adjoints-of-ODEs-for-Solving-Inverse-Problems"><a class="docs-heading-anchor" href="#Let&#39;s-Dig-Deep-Into-One-Case:-Adjoints-of-ODEs-for-Solving-Inverse-Problems">Let&#39;s Dig Deep Into One Case: Adjoints of ODEs for Solving Inverse Problems</a><a id="Let&#39;s-Dig-Deep-Into-One-Case:-Adjoints-of-ODEs-for-Solving-Inverse-Problems-1"></a><a class="docs-heading-anchor-permalink" href="#Let&#39;s-Dig-Deep-Into-One-Case:-Adjoints-of-ODEs-for-Solving-Inverse-Problems" title="Permalink"></a></h3><p>To really highlight how JIT compilation and automatic differentiation integration can change algorithms, let&#39;s look at the problem of differentiating an ODE solver. As is <a href="https://www.youtube.com/watch?v=Xwh42RhB7O4">derived and discussed in detail at a seminar with the American Statistical Association</a>, there are many ways to implement well-known “adjoint” methods which are required for performance. Each has different stability and performance trade-offs, and <a href="https://sensitivity.sciml.ai/stable/manual/differential_equation_sensitivities/">Julia&#39;s SciML is the only system to systemically offer all of the trade-off options</a>. In many cases, using analytical adjoints of a solver is not advised due to performance reasons, <a href="https://www.stochasticlifestyle.com/direct-automatic-differentiation-of-solvers-vs-analytical-adjoints-which-is-better/">with the trade-off described in detail here</a>. Likewise, even when analytical adjoints are used, it turns out that for general nonlinear equations there is a trick which uses automatic differentiation in the construction of the analytical adjoint to improve its performance. As demonstrated in <a href="https://ieeexplore.ieee.org/abstract/document/9622796/">this publication</a>, this can lead to about 2-3 orders of magnitude performance improvements. These AD-enhanced adjoints are showcased as the seeding methods in this plot:</p><p><img src="https://i0.wp.com/www.stochasticlifestyle.com/wp-content/uploads/2022/10/Capture7.png?w=2091&amp;ssl=1" alt/></p><p>Unless one directly defines special “vjp” functions, this is how the Julia SciML methods achieve orders of magnitude performance advantages over CVODES&#39;s adjoints and PETSC&#39;s TS-adjoint.</p><p>Moral of the story, even there are many reasons to use automatic differentiation of a solver, and even if an analytical adjoint rule is used for some specific performance reason, that analytical expression can often times be accelerated by orders of magnitude itself by embedding some form of automatic differentiation into it. This is just one algorithm of many which are optimized in this fashion.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../r/">« Getting Started with Julia&#39;s SciML for the R User</a><a class="docs-footer-nextpage" href="../../showcase/showcase/">The SciML Showcase »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Tuesday 20 May 2025 11:48">Tuesday 20 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
