<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SciML Equation Solvers Overview · Overview of SciML</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://scimldocs.sciml.ai/stable/highlevels/equation_solvers/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of SciML</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">The SciML Open Souce Software Ecosystem</a></li><li class="is-active"><a class="tocitem" href>SciML Equation Solvers Overview</a><ul class="internal"><li><a class="tocitem" href="#LinearSolve.jl:-Unified-Interface-for-Linear-Solvers"><span>LinearSolve.jl: Unified Interface for Linear Solvers</span></a></li><li><a class="tocitem" href="#NonlinearSolve.jl:-Unified-Interface-for-Nonlinear-Solvers"><span>NonlinearSolve.jl: Unified Interface for Nonlinear Solvers</span></a></li><li><a class="tocitem" href="#DifferentialEquations.jl:-Unified-Interface-for-Differential-Equation-Solvers"><span>DifferentialEquations.jl: Unified Interface for Differential Equation Solvers</span></a></li><li><a class="tocitem" href="#Optimization.jl:-Unified-Interface-for-Optimization"><span>Optimization.jl: Unified Interface for Optimization</span></a></li><li><a class="tocitem" href="#Integrals.jl:-Unified-Interface-for-Numerical-Integration"><span>Integrals.jl: Unified Interface for Numerical Integration</span></a></li><li><a class="tocitem" href="#JumpProcesses.jl:-Stochastic-Simulation-Algorithms-for-Jump-Processes,-Jump-ODEs,-and-Jump-Diffusions"><span>JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</span></a></li><li class="toplevel"><a class="tocitem" href="#Third-Party-Libraries-to-Note"><span>Third Party Libraries to Note</span></a></li><li><a class="tocitem" href="#JuMP.jl:-Julia-for-Mathematical-Programming"><span>JuMP.jl: Julia for Mathematical Programming</span></a></li><li><a class="tocitem" href="#FractionalDiffEq.jl:-Fractional-Differential-Equation-Solvers"><span>FractionalDiffEq.jl: Fractional Differential Equation Solvers</span></a></li><li><a class="tocitem" href="#ManifoldDiffEq.jl:-Solvers-for-Differential-Equations-on-Manifolds"><span>ManifoldDiffEq.jl: Solvers for Differential Equations on Manifolds</span></a></li><li><a class="tocitem" href="#Manopt.jl:-Optimization-on-Manifolds"><span>Manopt.jl: Optimization on Manifolds</span></a></li></ul></li><li><a class="tocitem" href="../partial_differential_equation_solvers/">SciML Partial Differential Equations (PDE) Overview</a></li><li><a class="tocitem" href="../modeling_tools/">SciML Modeling Libraries</a></li><li><a class="tocitem" href="../inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems Overview</a></li><li><a class="tocitem" href="../array_libraries/">SciML Array Libraries</a></li><li><a class="tocitem" href="../uncertainty_quantification/">Uncertainty Quantification Overview</a></li><li><a class="tocitem" href="../simulation_analysis/">SciML Simulation Analysis Utilities</a></li><li><a class="tocitem" href="../machine_learning/">SciML Machine Learning Libraries Overview</a></li><li><a class="tocitem" href="../numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../learning_resources/">Curated Learning, Teaching, and Training Resouces</a></li><li><a class="tocitem" href="../interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../developer_documentation/">Developer Documentation</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SciML Equation Solvers Overview</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SciML Equation Solvers Overview</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/highlevels/equation_solvers.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="SciML-Equation-Solvers-Overview"><a class="docs-heading-anchor" href="#SciML-Equation-Solvers-Overview">SciML Equation Solvers Overview</a><a id="SciML-Equation-Solvers-Overview-1"></a><a class="docs-heading-anchor-permalink" href="#SciML-Equation-Solvers-Overview" title="Permalink"></a></h1><p>The SciML Equation Solvers cover a large set of <code>SciMLProblem</code>s with <code>SciMLAlgorithm</code>s that are efficient, numerically stable, and flexible. These methods tie into libraries like SciMLSensitivity.jl to be fully differentiable and compatible with machine learning pipelines, and are designed for integration with applications like parameter estimation, global sensitivity analysis, and more.</p><h2 id="LinearSolve.jl:-Unified-Interface-for-Linear-Solvers"><a class="docs-heading-anchor" href="#LinearSolve.jl:-Unified-Interface-for-Linear-Solvers">LinearSolve.jl: Unified Interface for Linear Solvers</a><a id="LinearSolve.jl:-Unified-Interface-for-Linear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#LinearSolve.jl:-Unified-Interface-for-Linear-Solvers" title="Permalink"></a></h2><p><a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> is the canonical library for solving <code>LinearProblem</code>s. It includes:</p><ul><li>Fast pure Julia LU factorizations which outperform standard BLAS</li><li>KLU for faster sparse LU factorization on unstructured matrices</li><li>UMFPACK for faster sparse LU factorization on matrices with some repeated structure</li><li>MKLPardiso wrappers for handling many sparse matrices faster than SuiteSparse (KLU, UMFPACK) methods</li><li>GPU-offloading for large dense matrices</li><li>Wrappers to all of the Krylov implementations (Krylov.jl, IterativeSolvers.jl, KrylovKit.jl) for easy testing of all of them. LinearSolve.jl handles the API differences, especially with the preconditioner definitions</li><li>A polyalgorithm that smartly chooses between these methods</li><li>A caching interface which automates caching of symbolic factorizations and numerical factorizations as optimally as possible</li><li>Compatible with arbitrary AbstractArray and Number types, such as GPU-based arrays, uncertainty quantification number types, and more.</li></ul><h2 id="NonlinearSolve.jl:-Unified-Interface-for-Nonlinear-Solvers"><a class="docs-heading-anchor" href="#NonlinearSolve.jl:-Unified-Interface-for-Nonlinear-Solvers">NonlinearSolve.jl: Unified Interface for Nonlinear Solvers</a><a id="NonlinearSolve.jl:-Unified-Interface-for-Nonlinear-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#NonlinearSolve.jl:-Unified-Interface-for-Nonlinear-Solvers" title="Permalink"></a></h2><p><a href="https://github.com/SciML/NonlinearSolve.jl">NonlinearSolve.jl</a> is the canonical library for solving <code>NonlinearProblem</code>s. It includes:</p><ul><li>Fast non-allocating implementations on static arrays of common methods (Newton-Rhapson)</li><li>Bracketing methods (Bisection, Falsi) for methods with known upper and lower bounds</li><li>Wrappers to common other solvers (NLsolve.jl, MINPACK, KINSOL from Sundials) for trust region methods, line search based approaches, etc.</li><li>Built over the LinearSolve.jl API for maximum flexibility and performance in the solving approach</li><li>Compatible with arbitrary AbstractArray and Number types, such as GPU-based arrays, uncertainty quantification number types, and more.</li></ul><h2 id="DifferentialEquations.jl:-Unified-Interface-for-Differential-Equation-Solvers"><a class="docs-heading-anchor" href="#DifferentialEquations.jl:-Unified-Interface-for-Differential-Equation-Solvers">DifferentialEquations.jl: Unified Interface for Differential Equation Solvers</a><a id="DifferentialEquations.jl:-Unified-Interface-for-Differential-Equation-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#DifferentialEquations.jl:-Unified-Interface-for-Differential-Equation-Solvers" title="Permalink"></a></h2><p><a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> is the canonical library for solving <code>DEProblem</code>s. This includes:</p><ul><li>Discrete equations (function maps, discrete stochastic (Gillespie/Markov) simulations) (<code>DiscreteProblem</code>)</li><li>Ordinary differential equations (ODEs) (<code>ODEProblem</code>)</li><li>Split and Partitioned ODEs (Symplectic integrators, IMEX Methods) (<code>SplitODEProblem</code>)</li><li>Stochastic ordinary differential equations (SODEs or SDEs) (<code>SDEProblem</code>)</li><li>Stochastic differential-algebraic equations (SDAEs) (<code>SDEProblem</code> with mass matrices)</li><li>Random differential equations (RODEs or RDEs) (<code>RODEProblem</code>)</li><li>Differential algebraic equations (DAEs) (<code>DAEProblem</code> and <code>ODEProblem</code> with mass matrices)</li><li>Delay differential equations (DDEs) (<code>DDEProblem</code>)</li><li>Neutral, retarded, and algebraic delay differential equations (NDDEs, RDDEs, and DDAEs)</li><li>Stochastic delay differential equations (SDDEs) (<code>SDDEProblem</code>)</li><li>Experimental support for stochastic neutral, retarded, and algebraic delay differential equations (SNDDEs, SRDDEs, and SDDAEs)</li><li>Mixed discrete and continuous equations (Hybrid Equations, Jump Diffusions) (<code>DEProblem</code>s with callbacks and <code>JumpProblem</code>)</li></ul><p>The well-optimized DifferentialEquations solvers benchmark as some of the fastest implementations of classic algorithms. It also includes algorithms from recent research which routinely outperform the &quot;standard&quot; C/Fortran methods, and algorithms optimized for high-precision and HPC applications. Simultaneously, it wraps the classic C/Fortran methods, making it easy to switch over to them whenever necessary. Solving differential equations with different methods from different languages and packages can be done by changing one line of code, allowing for easy benchmarking to ensure you are using the fastest method possible.</p><p>DifferentialEquations.jl integrates with the Julia package sphere with:</p><ul><li>GPU acceleration through CUDAnative.jl and CuArrays.jl</li><li>Automated sparsity detection with <a href="https://github.com/JuliaSymbolics/Symbolics.jl">Symbolics.jl</a></li><li>Automatic Jacobian coloring with <a href="https://github.com/JuliaDiff/SparseDiffTools.jl">SparseDiffTools.jl</a>, allowing for fast solutions to problems with sparse or structured (Tridiagonal, Banded, BlockBanded, etc.) Jacobians</li><li>Allowing the specification of linear solvers for maximal efficiency</li><li>Progress meter integration with the Juno IDE for estimated time to solution</li><li>Automatic plotting of time series and phase plots</li><li>Built-in interpolations</li><li>Wraps for common C/Fortran methods, like Sundials and Hairer&#39;s radau</li><li>Arbitrary precision with BigFloats and Arbfloats</li><li>Arbitrary array types, allowing the definition of differential equations on matrices and distributed arrays</li><li>Unit-checked arithmetic with Unitful</li></ul><h2 id="Optimization.jl:-Unified-Interface-for-Optimization"><a class="docs-heading-anchor" href="#Optimization.jl:-Unified-Interface-for-Optimization">Optimization.jl: Unified Interface for Optimization</a><a id="Optimization.jl:-Unified-Interface-for-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization.jl:-Unified-Interface-for-Optimization" title="Permalink"></a></h2><p><a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a> is the canonical library for solving <code>OptimizationProblem</code>s. It includes wrappers of most of the Julia nonlinear optimization ecosystem, allowing one syntax to use all packages in a uniform manner. This covers:</p><ul><li>OptimizationBBO for <a href="https://github.com/robertfeldt/BlackBoxOptim.jl">BlackBoxOptim.jl</a></li><li>OptimizationEvolutionary for <a href="https://github.com/wildart/Evolutionary.jl">Evolutionary.jl</a> (see also <a href="https://wildart.github.io/Evolutionary.jl/dev/">this documentation</a>)</li><li>OptimizationGCMAES for <a href="https://github.com/AStupidBear/GCMAES.jl">GCMAES.jl</a></li><li>OptimizationMOI for <a href="https://github.com/jump-dev/MathOptInterface.jl">MathOptInterface.jl</a> (usage of algorithm via MathOptInterface API; see also the API <a href="https://jump.dev/MathOptInterface.jl/stable/">documentation</a>)</li><li>OptimizationMetaheuristics for <a href="https://github.com/jmejia8/Metaheuristics.jl">Metaheuristics.jl</a> (see also <a href="https://jmejia8.github.io/Metaheuristics.jl/stable/">this documentation</a>)</li><li>OptimizationMultistartOptimization for <a href="https://github.com/tpapp/MultistartOptimization.jl">MultistartOptimization.jl</a> (see also <a href="https://juliahub.com/docs/MultistartOptimization/cVZvi/0.1.0/">this documentation</a>)</li><li>OptimizationNLopt for <a href="https://github.com/JuliaOpt/NLopt.jl">NLopt.jl</a> (usage via the NLopt API; see also the available <a href="https://nlopt.readthedocs.io/en/latest/NLopt_Algorithms/">algorithms</a>)</li><li>OptimizationNOMAD for <a href="https://github.com/bbopt/NOMAD.jl">NOMAD.jl</a> (see also <a href="https://bbopt.github.io/NOMAD.jl/stable/">this documentation</a>)</li><li>OptimizationNonconvex for <a href="https://github.com/JuliaNonconvex/Nonconvex.jl">Nonconvex.jl</a> (see also <a href="https://julianonconvex.github.io/Nonconvex.jl/stable/">this documentation</a>)</li><li>OptimizationQuadDIRECT for <a href="https://github.com/timholy/QuadDIRECT.jl">QuadDIRECT.jl</a></li><li>OptimizationSpeedMapping for <a href="https://github.com/NicolasL-S/SpeedMapping.jl">SpeedMapping.jl</a> (see also <a href="https://nicolasl-s.github.io/SpeedMapping.jl/stable/">this documentation</a>)</li></ul><h2 id="Integrals.jl:-Unified-Interface-for-Numerical-Integration"><a class="docs-heading-anchor" href="#Integrals.jl:-Unified-Interface-for-Numerical-Integration">Integrals.jl: Unified Interface for Numerical Integration</a><a id="Integrals.jl:-Unified-Interface-for-Numerical-Integration-1"></a><a class="docs-heading-anchor-permalink" href="#Integrals.jl:-Unified-Interface-for-Numerical-Integration" title="Permalink"></a></h2><p><a href="https://github.com/SciML/Integrals.jl">Integrals.jl</a> is the canonical library for solving <code>IntegralsProblem</code>s. It includes wrappers of most of the Julia quadrature ecosystem, allowing one syntax to use all packages in a uniform manner. This covers:</p><ul><li>Gauss-Kronrod quadrature</li><li>Cubature methods (both <code>h</code> and <code>p</code> cubature)</li><li>Adaptive Monte Carlo methods</li></ul><h2 id="JumpProcesses.jl:-Stochastic-Simulation-Algorithms-for-Jump-Processes,-Jump-ODEs,-and-Jump-Diffusions"><a class="docs-heading-anchor" href="#JumpProcesses.jl:-Stochastic-Simulation-Algorithms-for-Jump-Processes,-Jump-ODEs,-and-Jump-Diffusions">JumpProcesses.jl: Stochastic Simulation Algorithms for Jump Processes, Jump-ODEs, and Jump-Diffusions</a><a id="JumpProcesses.jl:-Stochastic-Simulation-Algorithms-for-Jump-Processes,-Jump-ODEs,-and-Jump-Diffusions-1"></a><a class="docs-heading-anchor-permalink" href="#JumpProcesses.jl:-Stochastic-Simulation-Algorithms-for-Jump-Processes,-Jump-ODEs,-and-Jump-Diffusions" title="Permalink"></a></h2><p><a href="https://github.com/SciML/JumpProcesses.jl">JumpProcesses.jl</a> is the library for Poisson jump processes, also known as chemical master equations or Gillespie simulations, for simulating chemical reaction networks and other applications. It allows for solving with many methods, including:</p><ul><li><code>Direct</code>: the Gillespie Direct method SSA.</li><li><code>RDirect</code>: A variant of Gillespie&#39;s Direct method that uses rejection to sample the next reaction.</li><li><em><code>DirectCR</code></em>: The Composition-Rejection Direct method of Slepoy et al. For large networks and linear chain-type networks it will often give better performance than <code>Direct</code>. (Requires dependency graph, see below.)</li><li><code>DirectFW</code>: the Gillespie Direct method SSA with <code>FunctionWrappers</code>. This aggregator uses a different internal storage format for collections of <code>ConstantRateJumps</code>.</li><li><code>FRM</code>: the Gillespie first reaction method SSA. <code>Direct</code> should generally offer better performance and be preferred to <code>FRM</code>.</li><li><code>FRMFW</code>: the Gillespie first reaction method SSA with <code>FunctionWrappers</code>.</li><li><em><code>NRM</code></em>: The Gibson-Bruck Next Reaction Method. For some reaction network  structures this may offer better performance than <code>Direct</code> (for example,  large, linear chains of reactions). (Requires dependency graph, see below.)</li><li><em><code>RSSA</code></em>: The Rejection SSA (RSSA) method of Thanh et al. With <code>RSSACR</code>, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)</li><li><em><code>RSSACR</code></em>: The Rejection SSA (RSSA) with Composition-Rejection method of Thanh et al. With <code>RSSA</code>, for very large reaction networks it often offers the best performance of all methods. (Requires dependency graph, see below.)</li><li><em><code>SortingDirect</code></em>: The Sorting Direct Method of McCollum et al. It will usually offer performance as good as <code>Direct</code>, and for some systems can offer substantially better performance. (Requires dependency graph, see below.)</li></ul><p>The design of JumpProcesses.jl composes with DifferentialEquations.jl, allowing for discrete stochastic chemical reactions to be easily mixed with differential equation models, allowing for simulation of hybrid systems, jump diffusions, and differential equations driven by Levy processes.</p><p>In addition, JumpProcesses&#39;s interfaces allow for solving with regular jump methods, such as adaptive Tau-Leaping.</p><h1 id="Third-Party-Libraries-to-Note"><a class="docs-heading-anchor" href="#Third-Party-Libraries-to-Note">Third Party Libraries to Note</a><a id="Third-Party-Libraries-to-Note-1"></a><a class="docs-heading-anchor-permalink" href="#Third-Party-Libraries-to-Note" title="Permalink"></a></h1><h2 id="JuMP.jl:-Julia-for-Mathematical-Programming"><a class="docs-heading-anchor" href="#JuMP.jl:-Julia-for-Mathematical-Programming">JuMP.jl: Julia for Mathematical Programming</a><a id="JuMP.jl:-Julia-for-Mathematical-Programming-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP.jl:-Julia-for-Mathematical-Programming" title="Permalink"></a></h2><p>While Optimization.jl is the preferred library for nonlinear optimization, for all other forms of optimization <a href="https://github.com/jump-dev/JuMP.jl">Julia for Mathematical Programming (JuMP)</a> is the star. JuMP is the leading choice in Julia for doing:</p><ul><li>Linear Programming</li><li>Quadratic Programming</li><li>Convex Programming</li><li>Conic Programming</li><li>Semidefinite Programming</li><li>Mixed-Complementarity Programming</li><li>Integer Programming</li><li>Mixed Integer (nonlinear/linear) Programming</li><li>(Mixed Integer) Second Order Conic Programming</li></ul><p>JuMP can also be used for some nonlinear programming, though the Optimization.jl bindings to the JuMP solvers (via MathOptInterface.jl) is generally preferred.</p><h2 id="FractionalDiffEq.jl:-Fractional-Differential-Equation-Solvers"><a class="docs-heading-anchor" href="#FractionalDiffEq.jl:-Fractional-Differential-Equation-Solvers">FractionalDiffEq.jl: Fractional Differential Equation Solvers</a><a id="FractionalDiffEq.jl:-Fractional-Differential-Equation-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#FractionalDiffEq.jl:-Fractional-Differential-Equation-Solvers" title="Permalink"></a></h2><p><a href="https://github.com/SciFracX/FractionalDiffEq.jl">FractionalDiffEq.jl</a> is a set of high-performance solvers for fractional differential equations.</p><h2 id="ManifoldDiffEq.jl:-Solvers-for-Differential-Equations-on-Manifolds"><a class="docs-heading-anchor" href="#ManifoldDiffEq.jl:-Solvers-for-Differential-Equations-on-Manifolds">ManifoldDiffEq.jl: Solvers for Differential Equations on Manifolds</a><a id="ManifoldDiffEq.jl:-Solvers-for-Differential-Equations-on-Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#ManifoldDiffEq.jl:-Solvers-for-Differential-Equations-on-Manifolds" title="Permalink"></a></h2><p><a href="https://github.com/JuliaManifolds/ManifoldDiffEq.jl">ManifoldDiffEq.jl</a> is a set of high-performance solvers for differential equations on manifolds using methods such as Lie Group actions and frozen coefficients (Crouch-Grossman methods). These solvers can in many cases out-perform the OrdinaryDiffEq.jl nonautonomous operator ODE solvers by using methods specialized on manifold definitions of ManifoldsBase.</p><h2 id="Manopt.jl:-Optimization-on-Manifolds"><a class="docs-heading-anchor" href="#Manopt.jl:-Optimization-on-Manifolds">Manopt.jl: Optimization on Manifolds</a><a id="Manopt.jl:-Optimization-on-Manifolds-1"></a><a class="docs-heading-anchor-permalink" href="#Manopt.jl:-Optimization-on-Manifolds" title="Permalink"></a></h2><p><a href="https://github.com/JuliaManifolds/Manopt.jl">ManOpt.jl</a> allows for easy and efficient solving of nonlinear optimization problems on manifolds.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« The SciML Open Souce Software Ecosystem</a><a class="docs-footer-nextpage" href="../partial_differential_equation_solvers/">SciML Partial Differential Equations (PDE) Overview »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 11 October 2022 12:25">Tuesday 11 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
