<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter Estimation, Bayesian Analysis, and Inverse Problems · Overview of Julia&#39;s SciML</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/stable/highlevels/inverse_problems/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/installation/">Installing SciML Software</a></li><li><a class="tocitem" href="../../getting_started/first_simulation/">Build and run your first simulation with Julia&#39;s SciML</a></li><li><a class="tocitem" href="../../getting_started/first_optimization/">Solve your first optimization problem</a></li><li><a class="tocitem" href="../../getting_started/fit_simulation/">Fit a simulation to a dataset</a></li><li><a class="tocitem" href="../../getting_started/find_root/">Find the root of an equation (i.e. solve f(u)=0)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../comparisons/python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../../comparisons/matlab/">Getting Started with  Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../../comparisons/r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li><a class="tocitem" href="../../comparisons/cppfortran/">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../../showcase/showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/missing_physics/">Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a></li><li><a class="tocitem" href="../../showcase/bayesian_neural_ode/">Uncertainty Quantified Deep Bayesian Model Discovery</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li><a class="tocitem" href="../../showcase/pinngpu/">GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li><li><a class="tocitem" href="../../showcase/massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li><li><a class="tocitem" href="../../showcase/gpu_spde/">GPU-Accelerated Stochastic Partial Differential Equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/ode_types/">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li><li><a class="tocitem" href="../../showcase/symbolic_analysis/">Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox" checked/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../equation_solvers/">Equation Solvers</a></li><li class="is-active"><a class="tocitem" href>Parameter Estimation, Bayesian Analysis, and Inverse Problems</a><ul class="internal"><li><a class="tocitem" href="#SciMLSensitivity.jl:-Local-Sensitivity-Analysis-and-Automatic-Differentiation-Support-for-Solvers"><span>SciMLSensitivity.jl: Local Sensitivity Analysis and Automatic Differentiation Support for Solvers</span></a></li><li><a class="tocitem" href="#DataDrivenDiffEq.jl:-Data-Driven-Modeling-and-Equation-Discovery"><span>DataDrivenDiffEq.jl: Data-Driven Modeling and Equation Discovery</span></a></li><li><a class="tocitem" href="#DiffEqParamEstim.jl:-Simplified-Parameter-Estimation-Interface"><span>DiffEqParamEstim.jl: Simplified Parameter Estimation Interface</span></a></li><li><a class="tocitem" href="#DiffEqBayes.jl:-Simplified-Bayesian-Estimation-Interface"><span>DiffEqBayes.jl: Simplified Bayesian Estimation Interface</span></a></li><li class="toplevel"><a class="tocitem" href="#Third-Party-Tools-of-Note"><span>Third-Party Tools of Note</span></a></li><li><a class="tocitem" href="#Turing.jl:-A-Flexible-Probabilistic-Programming-Language-for-Bayesian-Analysis"><span>Turing.jl: A Flexible Probabilistic Programming Language for Bayesian Analysis</span></a></li><li><a class="tocitem" href="#Topopt.jl:-Topology-Optimization-in-Julia"><span>Topopt.jl: Topology Optimization in Julia</span></a></li><li class="toplevel"><a class="tocitem" href="#Recommended-Automatic-Differentiation-Libraries"><span>Recommended Automatic Differentiation Libraries</span></a></li><li><a class="tocitem" href="#ForwardDiff.jl:-Operator-Overloading-Forward-Mode-Automatic-Differentiation"><span>ForwardDiff.jl: Operator-Overloading Forward Mode Automatic Differentiation</span></a></li><li><a class="tocitem" href="#Enzyme.jl:-LLVM-Level-Forward-and-Reverse-Mode-Automatic-Differentiation"><span>Enzyme.jl: LLVM-Level Forward and Reverse Mode Automatic Differentiation</span></a></li><li><a class="tocitem" href="#Zygote.jl:-Julia-Level-Source-to-Source-Reverse-Mode-Automatic-Differentiation"><span>Zygote.jl: Julia-Level Source-to-Source Reverse Mode Automatic Differentiation</span></a></li><li><a class="tocitem" href="#FiniteDiff.jl:-Fast-Finite-Difference-Approximations"><span>FiniteDiff.jl: Fast Finite Difference Approximations</span></a></li><li><a class="tocitem" href="#SparseDiffTools.jl:-Tools-for-Fast-Automatic-Differentiation-with-Sparse-Operators"><span>SparseDiffTools.jl: Tools for Fast Automatic Differentiation with Sparse Operators</span></a></li></ul></li><li><a class="tocitem" href="../partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">What is SciML?</a></li><li><a class="is-disabled">Solvers</a></li><li class="is-active"><a href>Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/highlevels/inverse_problems.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="parameter_estimation"><a class="docs-heading-anchor" href="#parameter_estimation">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a><a id="parameter_estimation-1"></a><a class="docs-heading-anchor-permalink" href="#parameter_estimation" title="Permalink"></a></h1><p>Parameter estimation for models and equations, also known as dynamic data analysis, solving the inverse problem, or Bayesian posterior estimation (when done probabilistically), is provided by the SciML tools for the equations in its set. In this introduction, we briefly present the relevant packages that facilitate parameter estimation, namely:</p><ul><li><a href="https://sensitivity.sciml.ai/">SciMLSensitivity.jl</a></li><li><a href="https://diffeqflux.sciml.ai/">DiffEqFlux.jl</a></li><li><a href="https://turing.ml/">Turing.jl</a></li><li><a href="https://datadriven.sciml.ai/dev/">DataDrivenDiffEq.jl</a></li><li><a href="https://diffeqparamestim.sciml.ai/dev/">DiffEqParamEstim.jl</a></li><li><a href="https://diffeqbayes.sciml.ai/dev/">DiffEqBayes.jl</a></li></ul><p>We also provide information regarding the respective strengths of these packages so that you can easily decide which one suits your needs best.</p><h2 id="SciMLSensitivity.jl:-Local-Sensitivity-Analysis-and-Automatic-Differentiation-Support-for-Solvers"><a class="docs-heading-anchor" href="#SciMLSensitivity.jl:-Local-Sensitivity-Analysis-and-Automatic-Differentiation-Support-for-Solvers">SciMLSensitivity.jl: Local Sensitivity Analysis and Automatic Differentiation Support for Solvers</a><a id="SciMLSensitivity.jl:-Local-Sensitivity-Analysis-and-Automatic-Differentiation-Support-for-Solvers-1"></a><a class="docs-heading-anchor-permalink" href="#SciMLSensitivity.jl:-Local-Sensitivity-Analysis-and-Automatic-Differentiation-Support-for-Solvers" title="Permalink"></a></h2><p>SciMLSensitivity.jl is the system for local sensitivity, which all other inverse problem methods rely on. This package defines the interactions between the equation solvers and automatic differentiation, defining fast overloads for forward and adjoint (reverse) sensitivity analysis for fast gradient and Jacobian calculations with respect to model inputs. Its documentation covers how to use direct differentiation of equation solvers in conjunction with tools like Optimization.jl to perform model calibration of ODEs against data, PDE-constrained optimization, nonlinear optimal controls analysis, and much more. As a lower level tool, this library is very versatile, feature-rich, and high-performance, giving all the tools required but not directly providing a higher level interface.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Sensitivity analysis is kept in a separate library from the solvers (SciMLSensitivity.jl), in order to not require all equation solvers to have a dependency on all automatic differentiation libraries. If automatic differentiation is applied to a solver library without importing SciMLSensitivity.jl, an error is thrown letting the user know to import SciMLSensitivity.jl for the functionality to exist.</p></div></div><h2 id="DataDrivenDiffEq.jl:-Data-Driven-Modeling-and-Equation-Discovery"><a class="docs-heading-anchor" href="#DataDrivenDiffEq.jl:-Data-Driven-Modeling-and-Equation-Discovery">DataDrivenDiffEq.jl: Data-Driven Modeling and Equation Discovery</a><a id="DataDrivenDiffEq.jl:-Data-Driven-Modeling-and-Equation-Discovery-1"></a><a class="docs-heading-anchor-permalink" href="#DataDrivenDiffEq.jl:-Data-Driven-Modeling-and-Equation-Discovery" title="Permalink"></a></h2><p>The distinguishing feature of this package is that its ultimate goal is to identify the differential equation model that generated the input data. Depending on the user&#39;s needs, the package can provide structural identification of a given differential equation (output in a symbolic form) or structural estimation (output as a function for prediction purposes).</p><h2 id="DiffEqParamEstim.jl:-Simplified-Parameter-Estimation-Interface"><a class="docs-heading-anchor" href="#DiffEqParamEstim.jl:-Simplified-Parameter-Estimation-Interface">DiffEqParamEstim.jl: Simplified Parameter Estimation Interface</a><a id="DiffEqParamEstim.jl:-Simplified-Parameter-Estimation-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#DiffEqParamEstim.jl:-Simplified-Parameter-Estimation-Interface" title="Permalink"></a></h2><p>This package is for simplified parameter estimation. While not as flexible of a system like DiffEqFlux.jl, it provides ready-made functions for doing standard optimization procedures like L2 fitting and MAP estimates. Among other features, it allows for the optimization of parameters in ODEs, stochastic problems, and delay differential equations.</p><h2 id="DiffEqBayes.jl:-Simplified-Bayesian-Estimation-Interface"><a class="docs-heading-anchor" href="#DiffEqBayes.jl:-Simplified-Bayesian-Estimation-Interface">DiffEqBayes.jl: Simplified Bayesian Estimation Interface</a><a id="DiffEqBayes.jl:-Simplified-Bayesian-Estimation-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#DiffEqBayes.jl:-Simplified-Bayesian-Estimation-Interface" title="Permalink"></a></h2><p>As the name suggests, this package has been designed to provide the estimation of differential equations parameters by Bayesian methods. It works in conjunction with <a href="https://turing.ml/">Turing.jl</a>, <a href="https://github.com/StanJulia/CmdStan.jl">CmdStan.jl</a>, <a href="https://github.com/tpapp/DynamicHMC.jl">DynamicHMC.jl</a>, and <a href="https://github.com/marcjwilliams1/ApproxBayes.jl">ApproxBayes.jl</a>. While not as flexible as direct usage of DiffEqFlux.jl or Turing.jl, DiffEqBayes.jl can be an approachable interface for those not familiar with Bayesian estimation, and provides a nice way to use Stan from pure Julia.</p><h1 id="Third-Party-Tools-of-Note"><a class="docs-heading-anchor" href="#Third-Party-Tools-of-Note">Third-Party Tools of Note</a><a id="Third-Party-Tools-of-Note-1"></a><a class="docs-heading-anchor-permalink" href="#Third-Party-Tools-of-Note" title="Permalink"></a></h1><h2 id="Turing.jl:-A-Flexible-Probabilistic-Programming-Language-for-Bayesian-Analysis"><a class="docs-heading-anchor" href="#Turing.jl:-A-Flexible-Probabilistic-Programming-Language-for-Bayesian-Analysis">Turing.jl: A Flexible Probabilistic Programming Language for Bayesian Analysis</a><a id="Turing.jl:-A-Flexible-Probabilistic-Programming-Language-for-Bayesian-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Turing.jl:-A-Flexible-Probabilistic-Programming-Language-for-Bayesian-Analysis" title="Permalink"></a></h2><p>In the context of differential equations and parameter estimation, Turing.jl allows for a Bayesian estimation of differential equations (used in conjunction with the high-level package DiffEqBayes.jl). For more examples on combining Turing.jl with DiffEqBayes.jl, see the documentation below. It is important to note that Turing.jl can also perform Bayesian estimation without relying on DiffEqBayes.jl (for an example, consult <a href="https://turing.ml/stable/tutorials/10-bayesian-differential-equations/">this</a> tutorial).</p><h2 id="Topopt.jl:-Topology-Optimization-in-Julia"><a class="docs-heading-anchor" href="#Topopt.jl:-Topology-Optimization-in-Julia">Topopt.jl: Topology Optimization in Julia</a><a id="Topopt.jl:-Topology-Optimization-in-Julia-1"></a><a class="docs-heading-anchor-permalink" href="#Topopt.jl:-Topology-Optimization-in-Julia" title="Permalink"></a></h2><p><a href="https://github.com/JuliaTopOpt/TopOpt.jl">Topopt.jl</a> solves topology optimization problems which are inverse problems on partial differential equations, solving for an optimal domain.</p><h1 id="Recommended-Automatic-Differentiation-Libraries"><a class="docs-heading-anchor" href="#Recommended-Automatic-Differentiation-Libraries">Recommended Automatic Differentiation Libraries</a><a id="Recommended-Automatic-Differentiation-Libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Automatic-Differentiation-Libraries" title="Permalink"></a></h1><p>Solving inverse problems commonly requires using automatic differentiation (AD). SciML includes extensive support for automatic differentiation throughout its solvers, though some AD libraries are more tested than others. The following libraries are the current recommendations of the SciML developers.</p><h2 id="ForwardDiff.jl:-Operator-Overloading-Forward-Mode-Automatic-Differentiation"><a class="docs-heading-anchor" href="#ForwardDiff.jl:-Operator-Overloading-Forward-Mode-Automatic-Differentiation">ForwardDiff.jl: Operator-Overloading Forward Mode Automatic Differentiation</a><a id="ForwardDiff.jl:-Operator-Overloading-Forward-Mode-Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#ForwardDiff.jl:-Operator-Overloading-Forward-Mode-Automatic-Differentiation" title="Permalink"></a></h2><p><a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> is a library for operator-overloading based forward-mode automatic differentiation. It&#39;s commonly used as the default method for generating Jacobians throughout the SciML solver libraries.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Because ForwardDiff.jl uses an operator overloading approach, uses of ForwardDiff.jl require that any caches for non-allocating mutating code allows for <code>Dual</code> numbers. To allow such code to be ForwardDiff.jl-compatible, see <a href="https://github.com/SciML/PreallocationTools.jl">PreallocationTools.jl</a>.</p></div></div><h2 id="Enzyme.jl:-LLVM-Level-Forward-and-Reverse-Mode-Automatic-Differentiation"><a class="docs-heading-anchor" href="#Enzyme.jl:-LLVM-Level-Forward-and-Reverse-Mode-Automatic-Differentiation">Enzyme.jl: LLVM-Level Forward and Reverse Mode Automatic Differentiation</a><a id="Enzyme.jl:-LLVM-Level-Forward-and-Reverse-Mode-Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Enzyme.jl:-LLVM-Level-Forward-and-Reverse-Mode-Automatic-Differentiation" title="Permalink"></a></h2><p><a href="https://github.com/EnzymeAD/Enzyme.jl">Enzyme.jl</a> is an LLVM-level AD library for forward and reverse automatic differentiation. It supports many features required for high performance, such as being able to differentiate mutating and interleave compiler optimization with the AD passes. However, it does not support all of the Julia runtime, and thus some code with many dynamic behaviors and garbage collection (GC) invocations can be incompatible with Enzyme. Enzyme.jl is quickly becoming the new standard AD for SciML.</p><h2 id="Zygote.jl:-Julia-Level-Source-to-Source-Reverse-Mode-Automatic-Differentiation"><a class="docs-heading-anchor" href="#Zygote.jl:-Julia-Level-Source-to-Source-Reverse-Mode-Automatic-Differentiation">Zygote.jl: Julia-Level Source-to-Source Reverse Mode Automatic Differentiation</a><a id="Zygote.jl:-Julia-Level-Source-to-Source-Reverse-Mode-Automatic-Differentiation-1"></a><a class="docs-heading-anchor-permalink" href="#Zygote.jl:-Julia-Level-Source-to-Source-Reverse-Mode-Automatic-Differentiation" title="Permalink"></a></h2><p><a href="https://github.com/FluxML/Zygote.jl">Zygote.jl</a> is the current standard user-level reverse-mode automatic differentiation library for the SciML solvers. User-level means that many library tutorials, like in SciMLSensitivity.jl and DiffEqFlux.jl, showcase user code using Zygote.jl. This is because Zygote.jl is the AD engine associated with the Flux machine learning library. However, Zygote.jl has many limitations which limits its performance in equation solver contexts, such as an inability to handle mutation and introducing many small allocations and type-instabilities. For this reason, the SciML equation solvers define differentiation overloads using <a href="https://github.com/JuliaDiff/ChainRules.jl">ChainRules.jl</a>, meaning that the equation solvers tend not to use Zygote.jl internally even if the user code uses <code>Zygote.gradient</code>. In this manner, the speed and performance of more advanced techniques can be preserved while using the Julia standard.</p><h2 id="FiniteDiff.jl:-Fast-Finite-Difference-Approximations"><a class="docs-heading-anchor" href="#FiniteDiff.jl:-Fast-Finite-Difference-Approximations">FiniteDiff.jl: Fast Finite Difference Approximations</a><a id="FiniteDiff.jl:-Fast-Finite-Difference-Approximations-1"></a><a class="docs-heading-anchor-permalink" href="#FiniteDiff.jl:-Fast-Finite-Difference-Approximations" title="Permalink"></a></h2><p><a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a> is the preferred fallback library for numerical differentiation and is commonly used by SciML solver libraries when automatic differentiation is disabled.</p><h2 id="SparseDiffTools.jl:-Tools-for-Fast-Automatic-Differentiation-with-Sparse-Operators"><a class="docs-heading-anchor" href="#SparseDiffTools.jl:-Tools-for-Fast-Automatic-Differentiation-with-Sparse-Operators">SparseDiffTools.jl: Tools for Fast Automatic Differentiation with Sparse Operators</a><a id="SparseDiffTools.jl:-Tools-for-Fast-Automatic-Differentiation-with-Sparse-Operators-1"></a><a class="docs-heading-anchor-permalink" href="#SparseDiffTools.jl:-Tools-for-Fast-Automatic-Differentiation-with-Sparse-Operators" title="Permalink"></a></h2><p><a href="https://github.com/JuliaDiff/SparseDiffTools.jl">SparseDiffTools.jl</a> is a library for sparse automatic differentiation. It&#39;s used internally by many of the SciML equation solver libraries, which explicitly expose interfaces for <code>colorvec</code> color vectors generated by SparseDiffTools.jl&#39;s methods. SparseDiffTools.jl also includes many features useful to users, such as operators for matrix-free Jacobian-vector and Hessian-vector products.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../equation_solvers/">« Equation Solvers</a><a class="docs-footer-nextpage" href="../partial_differential_equation_solvers/">Partial Differential Equations (PDE) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Friday 3 March 2023 04:58">Friday 3 March 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
