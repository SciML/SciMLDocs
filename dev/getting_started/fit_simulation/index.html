<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Fit a simulation to a dataset · Overview of Julia&#39;s SciML</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/stable/getting_started/fit_simulation/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installing SciML Software</a></li><li><a class="tocitem" href="../first_simulation/">Build and run your first simulation with Julia&#39;s SciML</a></li><li><a class="tocitem" href="../first_optimization/">Solve your first optimization problem</a></li><li class="is-active"><a class="tocitem" href>Fit a simulation to a dataset</a><ul class="internal"><li><a class="tocitem" href="#Required-Dependencies"><span>Required Dependencies</span></a></li><li><a class="tocitem" href="#Problem-Setup:-Fitting-Lotka-Volterra-Data"><span>Problem Setup: Fitting Lotka-Volterra Data</span></a></li><li><a class="tocitem" href="#Solution-as-Copy-Pastable-Code"><span>Solution as Copy-Pastable Code</span></a></li><li><a class="tocitem" href="#Step-by-Step-Solution"><span>Step-by-Step Solution</span></a></li></ul></li><li><a class="tocitem" href="../find_root/">Find the root of an equation (i.e. solve f(u)=0)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../comparisons/python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../../comparisons/matlab/">Getting Started with  Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../../comparisons/r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li><a class="tocitem" href="../../comparisons/cppfortran/">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../../showcase/showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/missing_physics/">Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a></li><li><a class="tocitem" href="../../showcase/bayesian_neural_ode/">Uncertainty Quantified Deep Bayesian Model Discovery</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li><a class="tocitem" href="../../showcase/pinngpu/">GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li><li><a class="tocitem" href="../../showcase/massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li><li><a class="tocitem" href="../../showcase/gpu_spde/">GPU-Accelerated Stochastic Partial Differential Equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/ode_types/">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li><li><a class="tocitem" href="../../showcase/symbolic_analysis/">Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li><li><a class="tocitem" href="../../showcase/optimization_under_uncertainty/">Optimization Under Uncertainty</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/equation_solvers/">Equation Solvers</a></li><li><a class="tocitem" href="../../highlevels/inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li><li><a class="tocitem" href="../../highlevels/partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../../highlevels/model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../../highlevels/symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../../highlevels/array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../../highlevels/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../highlevels/plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../../highlevels/implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../../highlevels/symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../../highlevels/interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../../highlevels/developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li><a class="is-disabled">New User Tutorials</a></li><li class="is-active"><a href>Fit a simulation to a dataset</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Fit a simulation to a dataset</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/getting_started/fit_simulation.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="fit_simulation"><a class="docs-heading-anchor" href="#fit_simulation">Fit a simulation to a dataset</a><a id="fit_simulation-1"></a><a class="docs-heading-anchor-permalink" href="#fit_simulation" title="Permalink"></a></h1><p>Running simulations is only half of the battle. Many times, in order to make the simulation realistic, you need to fit the simulation to data. The SciML ecosystem has <strong>integration with automatic differentiation and adjoint methods</strong> to automatically make the fitting process stable and efficient. Let&#39;s see this in action.</p><h2 id="Required-Dependencies"><a class="docs-heading-anchor" href="#Required-Dependencies">Required Dependencies</a><a id="Required-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Required-Dependencies" title="Permalink"></a></h2><p>The following parts of the SciML Ecosystem will be used in this tutorial:</p><table><tr><th style="text-align: left">Module</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a></td><td style="text-align: left">The differential equation solvers</td></tr><tr><td style="text-align: left"><a href="https://docs.sciml.ai/Optimization/stable/">Optimization.jl</a></td><td style="text-align: left">The numerical optimization package</td></tr><tr><td style="text-align: left"><a href="https://docs.sciml.ai/Optimization/stable/optimization_packages/polyalgorithms/">OptimizationPolyalgorithms.jl</a></td><td style="text-align: left">The optimizers we will use</td></tr><tr><td style="text-align: left"><a href="https://docs.sciml.ai/SciMLSensitivity/dev/">SciMLSensitivity.jl</a></td><td style="text-align: left">The connection of the SciML ecosystems to differentiation</td></tr></table><p>Along with the following general ecosystem packages:</p><table><tr><th style="text-align: left">Module</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="https://docs.juliaplots.org/stable/">Plots.jl</a></td><td style="text-align: left">The plotting and visualization package</td></tr><tr><td style="text-align: left"><a href="https://juliadiff.org/ForwardDiff.jl/stable/">ForwardDiff.jl</a></td><td style="text-align: left">The automatic differentiation package</td></tr></table><h2 id="Problem-Setup:-Fitting-Lotka-Volterra-Data"><a class="docs-heading-anchor" href="#Problem-Setup:-Fitting-Lotka-Volterra-Data">Problem Setup: Fitting Lotka-Volterra Data</a><a id="Problem-Setup:-Fitting-Lotka-Volterra-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Setup:-Fitting-Lotka-Volterra-Data" title="Permalink"></a></h2><p>Assume that we know that the dynamics of our system are given by the <a href="https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations">Lotka-Volterra dynamical system</a>: Let <span>$x(t)$</span> be the number of rabbits in the environment and <span>$y(t)$</span> be the number of wolves. This is the same dynamical system as <a href="../first_simulation/#first_sim">the first tutorial!</a> The equation that defines the evolution of the species is given as follows:</p><p class="math-container">\[\begin{align}
\frac{dx}{dt} &amp;= \alpha x - \beta x y\\
\frac{dy}{dt} &amp;= -\gamma y + \delta x y
\end{align}\]</p><p>where <span>$\alpha, \beta, \gamma, \delta$</span> are parameters. Starting from equal numbers of rabbits and wolves, <span>$x(0) = 1$</span> and <span>$y(0) = 1$</span>.</p><p>Now, in <a href="../first_simulation/#first_sim">the first tutorial</a>, we assumed:</p><blockquote><p>Luckily, a local guide provided us with some parameters that seem to match the system!</p></blockquote><p>Sadly, magical nymphs do not always show up and give us parameters. Thus in this case, let&#39;s assume that we are just given data that is representative of the solution with <span>$\alpha = 1.5$</span>, <span>$\beta = 1.0$</span>, <span>$\gamma = 3.0$</span>, and <span>$\delta = 1.0$</span>. This data is given over a time span of <span>$t_0 = 0$</span> to <span>$t_f = 10$</span> with data taken on both rabbits and wolves at every <span>$\Delta t = 1.$</span> Can we figure out what the parameter values should be directly from the data?</p><h2 id="Solution-as-Copy-Pastable-Code"><a class="docs-heading-anchor" href="#Solution-as-Copy-Pastable-Code">Solution as Copy-Pastable Code</a><a id="Solution-as-Copy-Pastable-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-as-Copy-Pastable-Code" title="Permalink"></a></h2><pre><code class="language-julia hljs">using DifferentialEquations, Optimization, OptimizationPolyalgorithms, SciMLSensitivity
using ForwardDiff, Plots

function lotka_volterra!(du, u, p, t)
    x, y = u
    α, β, δ, γ = p
    du[1] = dx = α * x - β * x * y
    du[2] = dy = -δ * y + γ * x * y
end

# Initial condition
u0 = [1.0, 1.0]

# Simulation interval
tspan = (0.0, 10.0)

# LV equation parameter. p = [α, β, δ, γ]
p = [1.5, 1.0, 3.0, 1.0]

# Setup the ODE problem, then solve
prob = ODEProblem(lotka_volterra!, u0, tspan, p)
datasol = solve(prob, saveat = 1)
data = Array(datasol)

## Now do the optimization process
function loss(newp)
    newprob = remake(prob, p = newp)
    sol = solve(newprob, saveat = 1)
    loss = sum(abs2, sol .- data)
    return loss, sol
end

callback = function (p, l, sol)
    display(l)
    plt = plot(sol, ylim = (0, 6), label = &quot;Current Prediction&quot;)
    scatter!(plt, datasol, label = &quot;Data&quot;)
    display(plt)
    # Tell Optimization.solve to not halt the optimization. If return true, then
    # optimization stops.
    return false
end

adtype = Optimization.AutoForwardDiff()
pguess = [1.0, 1.2, 2.5, 1.2]
optf = Optimization.OptimizationFunction((x, p) -&gt; loss(x), adtype)
optprob = Optimization.OptimizationProblem(optf, pguess)

result_ode = Optimization.solve(optprob, PolyOpt(),
                                callback = callback,
                                maxiters = 200)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 4-element Vector{Float64}:
 1.5008285793213638
 1.0011236254329783
 2.998186907788592
 0.9999450875602682</code></pre><h2 id="Step-by-Step-Solution"><a class="docs-heading-anchor" href="#Step-by-Step-Solution">Step-by-Step Solution</a><a id="Step-by-Step-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-by-Step-Solution" title="Permalink"></a></h2><h3 id="Step-1:-Install-and-Import-the-Required-Packages"><a class="docs-heading-anchor" href="#Step-1:-Install-and-Import-the-Required-Packages">Step 1: Install and Import the Required Packages</a><a id="Step-1:-Install-and-Import-the-Required-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Install-and-Import-the-Required-Packages" title="Permalink"></a></h3><p>To do this tutorial, we will need a few components. This is done using the Julia Pkg REPL:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add([
            &quot;DifferentialEquations&quot;,
            &quot;Optimization&quot;,
            &quot;OptimizationPolyalgorithms&quot;,
            &quot;SciMLSensitivity&quot;,
            &quot;ForwardDiff&quot;,
            &quot;Plots&quot;,
        ])</code></pre><p>Now we&#39;re ready. Let&#39;s load in these packages:</p><pre><code class="language-julia hljs">using DifferentialEquations, Optimization, OptimizationPolyalgorithms, SciMLSensitivity
using ForwardDiff, Plots</code></pre><h3 id="Step-2:-Generate-the-Training-Data"><a class="docs-heading-anchor" href="#Step-2:-Generate-the-Training-Data">Step 2: Generate the Training Data</a><a id="Step-2:-Generate-the-Training-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Generate-the-Training-Data" title="Permalink"></a></h3><p>In our example, we assumed that we had data representative of the solution with <span>$\alpha = 1.5$</span>, <span>$\beta = 1.0$</span>, <span>$\gamma = 3.0$</span>, and <span>$\delta = 1.0$</span>. Let&#39;s make that training data. The way we can do that is by defining the ODE with those parameters and simulating it. Unlike <a href="../first_simulation/#first_sim">the first tutorial</a>, which used ModelingToolkit, let&#39;s demonstrate using <a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a> to directly define the ODE for the numerical solvers.</p><p>To do this, we define a vector-based mutating function that calculates the derivatives for our system. We will define our system as a vector <code>u = [x,y]</code>, and thus <code>u[1] = x</code> and <code>u[2] = y</code>. This means that we need to calculate the derivative as <code>du = [dx,dy]</code>. Our parameters will simply be the vector <code>p = [α, β, δ, γ]</code>. Writing down the Lotka-Volterra equations in the DifferentialEquations.jl direct form thus looks like the following:</p><pre><code class="language-julia hljs">function lotka_volterra!(du, u, p, t)
    x, y = u
    α, β, δ, γ = p
    du[1] = α * x - β * x * y
    du[2] = -δ * y + γ * x * y
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">lotka_volterra! (generic function with 1 method)</code></pre><p>Now we need to define the initial condition, time span, and parameter vector to simulate with. Following the problem setup, this looks like:</p><pre><code class="language-julia hljs"># Initial condition
u0 = [1.0, 1.0]

# Simulation interval
tspan = (0.0, 10.0)

# LV equation parameter. p = [α, β, δ, γ]
p = [1.5, 1.0, 3.0, 1.0]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4-element Vector{Float64}:
 1.5
 1.0
 3.0
 1.0</code></pre><p>Now we bring these pieces all together to define the <code>ODEProblem</code> and solve it. Note that we solve this equation with the keyword argument <code>saveat = 1</code> so that it saves a point at every <span>$\Delta t = 1$</span>.</p><pre><code class="language-julia hljs"># Setup the ODE problem, then solve
prob = ODEProblem(lotka_volterra!, u0, tspan, p)
datasol = solve(prob, saveat = 1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: 1st order linear
t: 11-element Vector{Float64}:
  0.0
  1.0
  2.0
  3.0
  4.0
  5.0
  6.0
  7.0
  8.0
  9.0
 10.0
u: 11-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [2.7728223025987973, 0.2587244160530379]
 [6.773495154522353, 2.01535671926922]
 [0.9706713993069043, 1.9081445902225234]
 [1.886138339448311, 0.3234931620998045]
 [6.101542322046213, 0.6292015338792486]
 [1.3979925942243387, 3.458253782355543]
 [1.3350343536025087, 0.5080112218132244]
 [4.353034859443157, 0.31404338916019864]
 [3.246586407744904, 4.546928368468909]
 [1.0337581256020607, 0.9063703842886133]</code></pre><pre><code class="language-julia hljs">data = Array(datasol)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×11 Matrix{Float64}:
 1.0  2.77282   6.7735   0.970671  1.88614   …  4.35303   3.24659  1.03376
 1.0  0.258724  2.01536  1.90814   0.323493     0.314043  4.54693  0.90637</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"></div></div><p>For more details on using DifferentialEquations.jl, check out the <a href="https://docs.sciml.ai/DiffEqDocs/stable/getting_started/">getting started with DifferentialEquations.jl tutorial</a>.</p><h3 id="Step-3:-Set-Up-the-Cost-Function-for-Optimization"><a class="docs-heading-anchor" href="#Step-3:-Set-Up-the-Cost-Function-for-Optimization">Step 3: Set Up the Cost Function for Optimization</a><a id="Step-3:-Set-Up-the-Cost-Function-for-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Set-Up-the-Cost-Function-for-Optimization" title="Permalink"></a></h3><p>Now let&#39;s start the estimation process. First, let&#39;s define a loss function. For our loss function, we want to take a set of parameters, create a new ODE which has everything the same except for the changed parameters, solve this ODE with new parameters, and compare its predictions against the data. For this parameter changing, there is a useful functionality in the <a href="https://docs.sciml.ai/DiffEqDocs/stable/basics/problem/#Modification-of-problem-types">SciML problems interface</a> called <code>remake</code> which creates a new version of an existing <code>SciMLProblem</code> with the aspect you want changed. For example, if we wanted to change the initial condition <code>u0</code> of our ODE, we could do <code>remake(prob, u0 = newu0)</code> For our case, we want to change around just the parameters, so we can do <code>remake(prob, p = newp)</code></p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>remake</code> can change multiple items at once by passing more keyword arguments! I.e., <code>remake(prob, u0 = newu0, p = newp)</code> This can be used to extend the example to simultaneously learn the initial conditions and parameters!</p></div></div><p>Now use <code>remake</code> to build the cost function. After we solve the new problem, we will calculate the sum of squared errors as our metric. The sum of squares can be quickly written in Julia via <code>sum(abs2,x)</code>. Using this information, our loss looks like:</p><pre><code class="language-julia hljs">function loss(newp)
    newprob = remake(prob, p = newp)
    sol = solve(newprob, saveat = 1)
    loss = sum(abs2, sol .- data)
    return loss, sol
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">loss (generic function with 1 method)</code></pre><p>Notice that our loss function returns the loss value as the first return, but returns extra information (the solution at the new parameters) as extra return arguments. We will explain why this extra return information is helpful in the next section.</p><h3 id="Step-4:-Solve-the-Optimization-Problem"><a class="docs-heading-anchor" href="#Step-4:-Solve-the-Optimization-Problem">Step 4: Solve the Optimization Problem</a><a id="Step-4:-Solve-the-Optimization-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Solve-the-Optimization-Problem" title="Permalink"></a></h3><p>This step will look very similar to <a href="../first_optimization/#first_opt">the first optimization tutorial</a>, except now we have a new cost function. Here we&#39;ll also define a callback to monitor the solution process, more details about callbacks in Optimization.jl can be found <a href="https://docs.sciml.ai/Optimization/stable/API/solve/">here</a>.  However, this time, our function returns two things. The callback syntax is always <code>(value being optimized, arguments of loss return)</code> and thus this time the callback is given <code>(p, l, sol)</code>. See, returning the solution along with the loss as part of the loss function is useful because we have access to it in the callback to do things like plot the current solution against the data! Let&#39;s do that in the following way:</p><pre><code class="language-julia hljs">callback = function (p, l, sol)
    display(l)
    plt = plot(sol, ylim = (0, 6), label = &quot;Current Prediction&quot;)
    scatter!(plt, datasol, label = &quot;Data&quot;)
    display(plt)
    # Tell Optimization.solve to not halt the optimization. If return true, then
    # optimization stops.
    return false
end</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">#1 (generic function with 1 method)</code></pre><p>Thus every step of the optimization will show us the loss and a plot of how the solution looks vs the data at our current parameters.</p><p>Now, just like <a href="../first_optimization/#first_opt">the first optimization tutorial</a>, we setup our optimization problem. To do this, we need to come up with a <code>pguess</code>, an initial condition for the parameters which is our best guess of the true parameters. For this, we will use <code>pguess = [1.0, 1.2, 2.5, 1.2]</code>. Together, this looks like:</p><pre><code class="language-julia hljs">adtype = Optimization.AutoForwardDiff()
optf = Optimization.OptimizationFunction((x, p) -&gt; loss(x), adtype)
pguess = [1.0, 1.2, 2.5, 1.2]
optprob = Optimization.OptimizationProblem(optf, pguess)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OptimizationProblem. In-place: true
u0: 4-element Vector{Float64}:
 1.0
 1.2
 2.5
 1.2</code></pre><p>Now we solve the optimization problem:</p><pre><code class="language-julia hljs">result_ode = Optimization.solve(optprob, PolyOpt(),
                                callback = callback,
                                maxiters = 200)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: 4-element Vector{Float64}:
 1.5008285793213638
 1.0011236254329783
 2.998186907788592
 0.9999450875602682</code></pre><p>and the answer from the optimization is our desired parameters.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../first_optimization/">« Solve your first optimization problem</a><a class="docs-footer-nextpage" href="../find_root/">Find the root of an equation (i.e. solve f(u)=0) »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Thursday 6 July 2023 16:47">Thursday 6 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
