<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Build and run your first simulation with Julia&#39;s SciML ¬∑ Overview of Julia&#39;s SciML</title><meta name="title" content="Build and run your first simulation with Julia&#39;s SciML ¬∑ Overview of Julia&#39;s SciML"/><meta property="og:title" content="Build and run your first simulation with Julia&#39;s SciML ¬∑ Overview of Julia&#39;s SciML"/><meta property="twitter:title" content="Build and run your first simulation with Julia&#39;s SciML ¬∑ Overview of Julia&#39;s SciML"/><meta name="description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="twitter:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:url" content="https://docs.sciml.ai/stable/getting_started/first_simulation/"/><meta property="twitter:url" content="https://docs.sciml.ai/stable/getting_started/first_simulation/"/><link rel="canonical" href="https://docs.sciml.ai/stable/getting_started/first_simulation/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox" checked/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../installation/">Installing SciML Software</a></li><li class="is-active"><a class="tocitem" href>Build and run your first simulation with Julia&#39;s SciML</a><ul class="internal"><li><a class="tocitem" href="#Required-Dependencies"><span>Required Dependencies</span></a></li><li><a class="tocitem" href="#Our-Problem:-Simulate-the-Lotka-Volterra-Predator-Prey-Dynamics"><span>Our Problem: Simulate the Lotka-Volterra Predator-Prey Dynamics</span></a></li><li><a class="tocitem" href="#Solution-as-Copy-Pastable-Code"><span>Solution as Copy-Pastable Code</span></a></li><li><a class="tocitem" href="#Step-by-Step-Solution"><span>Step-by-Step Solution</span></a></li><li><a class="tocitem" href="#Step-3:-Define-the-ODEProblem"><span>Step 3: Define the ODEProblem</span></a></li><li><a class="tocitem" href="#Bonus-Step:-Emoji-Variables"><span>Bonus Step: Emoji Variables</span></a></li></ul></li><li><a class="tocitem" href="../first_optimization/">Solve your first optimization problem</a></li><li><a class="tocitem" href="../fit_simulation/">Fit a simulation to a dataset</a></li><li><a class="tocitem" href="../find_root/">Find the root of an equation (i.e. solve f(u)=0)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../comparisons/python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../../comparisons/matlab/">Getting Started with  Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../../comparisons/r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li><a class="tocitem" href="../../comparisons/cppfortran/">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../../showcase/showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/missing_physics/">Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a></li><li><a class="tocitem" href="../../showcase/bayesian_neural_ode/">Uncertainty Quantified Deep Bayesian Model Discovery</a></li><li><a class="tocitem" href="../../showcase/blackhole/">Discovering the Relativistic Corrections to Binary Black Hole Dynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li><a class="tocitem" href="../../showcase/pinngpu/">GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li><li><a class="tocitem" href="../../showcase/massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li><li><a class="tocitem" href="../../showcase/gpu_spde/">GPU-Accelerated Stochastic Partial Differential Equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../showcase/ode_types/">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li><li><a class="tocitem" href="../../showcase/symbolic_analysis/">Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li><li><a class="tocitem" href="../../showcase/optimization_under_uncertainty/">Optimization Under Uncertainty</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/equation_solvers/">Equation Solvers</a></li><li><a class="tocitem" href="../../highlevels/inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li><li><a class="tocitem" href="../../highlevels/partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../../highlevels/model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../../highlevels/symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../../highlevels/array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../../highlevels/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../highlevels/plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../../highlevels/implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../../highlevels/symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../../highlevels/interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../../highlevels/developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Getting Started</a></li><li><a class="is-disabled">New User Tutorials</a></li><li class="is-active"><a href>Build and run your first simulation with Julia&#39;s SciML</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Build and run your first simulation with Julia&#39;s SciML</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs" title="View the repository on GitHub"><span class="docs-icon fa-brands">ÔÇõ</span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/getting_started/first_simulation.md" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="first_sim"><a class="docs-heading-anchor" href="#first_sim">Build and run your first simulation with Julia&#39;s SciML</a><a id="first_sim-1"></a><a class="docs-heading-anchor-permalink" href="#first_sim" title="Permalink"></a></h1><p>In this tutorial, we will build and run our first simulation with SciML!</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This tutorial assumes that you have already installed Julia on your system. If you have not done so already, please <a href="../installation/#installation">follow the installation tutorial first</a>.</p></div></div><p>To build our simulation, we will use the <a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit</a> system for modeling and simulation. ModelingToolkit is a bit higher level than directly defining code for a differential equation system: it&#39;s a symbolic system that will automatically simplify our models, optimize our code, and generate compelling visualizations. Sounds neat? Let&#39;s dig in.</p><h2 id="Required-Dependencies"><a class="docs-heading-anchor" href="#Required-Dependencies">Required Dependencies</a><a id="Required-Dependencies-1"></a><a class="docs-heading-anchor-permalink" href="#Required-Dependencies" title="Permalink"></a></h2><p>The following parts of the SciML Ecosystem will be used in this tutorial:</p><table><tr><th style="text-align: left">Module</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit.jl</a></td><td style="text-align: left">The symbolic modeling environment</td></tr><tr><td style="text-align: left"><a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl</a></td><td style="text-align: left">The differential equation solvers</td></tr><tr><td style="text-align: left"><a href="https://docs.juliaplots.org/stable/">Plots.jl</a></td><td style="text-align: left">The plotting and visualization package</td></tr></table><h2 id="Our-Problem:-Simulate-the-Lotka-Volterra-Predator-Prey-Dynamics"><a class="docs-heading-anchor" href="#Our-Problem:-Simulate-the-Lotka-Volterra-Predator-Prey-Dynamics">Our Problem: Simulate the Lotka-Volterra Predator-Prey Dynamics</a><a id="Our-Problem:-Simulate-the-Lotka-Volterra-Predator-Prey-Dynamics-1"></a><a class="docs-heading-anchor-permalink" href="#Our-Problem:-Simulate-the-Lotka-Volterra-Predator-Prey-Dynamics" title="Permalink"></a></h2><p>The dynamics of our system are given by the <a href="https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations">Lotka-Volterra dynamical system</a>: Let <span>$x(t)$</span> be the number of rabbits in the environment and <span>$y(t)$</span> be the number of wolves. The equation that defines the evolution of the species is given as follows:</p><p class="math-container">\[\begin{align}
\frac{dx}{dt} &amp;= \alpha x - \beta x y\\
\frac{dy}{dt} &amp;= -\gamma y + \delta x y
\end{align}\]</p><p>where <span>$\alpha, \beta, \gamma, \delta$</span> are parameters. Starting from equal numbers of rabbits and wolves, <span>$x(0) = 1$</span> and <span>$y(0) = 1$</span>, we want to simulate this system from time <span>$t_0 = 0$</span> to <span>$t_f = 10$</span>. Luckily, a local guide provided us with some parameters that seem to match the system! These are <span>$\alpha = 1.5$</span>, <span>$\beta = 1.0$</span>, <span>$\gamma = 3.0$</span>, <span>$\delta = 1.0$</span>. How many rabbits and wolves will there be 10 months from now? And if <code>z = x + y</code>, i.e. the total number of animals at a given time, can we visualize this total number of animals at each time?</p><h2 id="Solution-as-Copy-Pastable-Code"><a class="docs-heading-anchor" href="#Solution-as-Copy-Pastable-Code">Solution as Copy-Pastable Code</a><a id="Solution-as-Copy-Pastable-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Solution-as-Copy-Pastable-Code" title="Permalink"></a></h2><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations, Plots

# Define our state variables: state(t) = initial condition
@variables t x(t)=1 y(t)=1 z(t)=2

# Define our parameters
@parameters Œ±=1.5 Œ≤=1.0 Œ≥=3.0 Œ¥=1.0

# Define our differential: takes the derivative with respect to `t`
D = Differential(t)

# Define the differential equations
eqs = [D(x) ~ Œ± * x - Œ≤ * x * y
       D(y) ~ -Œ≥ * y + Œ¥ * x * y
       z ~ x + y]

# Bring these pieces together into an ODESystem with independent variable t
@named sys = ODESystem(eqs, t)

# Symbolically Simplify the System
simpsys = structural_simplify(sys)

# Convert from a symbolic to a numerical problem to simulate
tspan = (0.0, 10.0)
prob = ODEProblem(simpsys, [], tspan)

# Solve the ODE
sol = solve(prob)

# Plot the solution
p1 = plot(sol, title = &quot;Rabbits vs Wolves&quot;)
p2 = plot(sol, idxs = z, title = &quot;Total Animals&quot;)

plot(p1, p2, layout = (2, 1))</code></pre><img src="eef254a5.svg" alt="Example block output"/><h2 id="Step-by-Step-Solution"><a class="docs-heading-anchor" href="#Step-by-Step-Solution">Step-by-Step Solution</a><a id="Step-by-Step-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-by-Step-Solution" title="Permalink"></a></h2><h3 id="Step-1:-Install-and-Import-the-Required-Packages"><a class="docs-heading-anchor" href="#Step-1:-Install-and-Import-the-Required-Packages">Step 1: Install and Import the Required Packages</a><a id="Step-1:-Install-and-Import-the-Required-Packages-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Install-and-Import-the-Required-Packages" title="Permalink"></a></h3><p>To do this tutorial, we will need a few components:</p><ul><li><a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit.jl, our modeling environment</a></li><li><a href="https://docs.sciml.ai/DiffEqDocs/stable/">DifferentialEquations.jl, the differential equation solvers</a></li><li><a href="https://docs.juliaplots.org/stable/">Plots.jl, our visualization tool</a></li></ul><p>To start, let&#39;s add these packages <a href="../installation/#installation">as demonstrated in the installation tutorial</a>:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add([&quot;ModelingToolkit&quot;, &quot;DifferentialEquations&quot;, &quot;Plots&quot;])</code></pre><p>Now we&#39;re ready. Let&#39;s load in these packages:</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations, Plots</code></pre><h3 id="Step-2:-Define-our-ODE-Equations"><a class="docs-heading-anchor" href="#Step-2:-Define-our-ODE-Equations">Step 2: Define our ODE Equations</a><a id="Step-2:-Define-our-ODE-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Define-our-ODE-Equations" title="Permalink"></a></h3><p>Now let&#39;s define our ODEs. We use the <code>ModelingToolkit.@variabes</code> statement to declare our variables. We have the independent variable time <code>t</code>, and then define our 3 state variables:</p><pre><code class="language-julia hljs"># Define our state variables: state(t) = initial condition
@variables t x(t)=1 y(t)=1 z(t)=2</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
t \\
x\left( t \right) \\
y\left( t \right) \\
z\left( t \right) \\
\end{array}
\right]
\end{equation}
 \]</p><p>Notice here that we use the form <code>state = default</code>, where on the right-hand side the default value of a state is interpreted to be its initial condition. This is then done similarly for parameters, where the default value is now the parameter value:</p><pre><code class="language-julia hljs"># Define our parameters
@parameters Œ±=1.5 Œ≤=1.0 Œ≥=3.0 Œ¥=1.0</code></pre><p class="math-container">\[ \begin{equation}
\left[
\begin{array}{c}
\alpha \\
\beta \\
\gamma \\
\delta \\
\end{array}
\right]
\end{equation}
 \]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Julia&#39;s text editors like VS Code are compatible with Unicode defined in a LaTeX form. Thus if you write <code>\alpha</code> into your REPL and then press <code>Tab</code>, it will auto-complete that into the Œ± symbol. That can make your code look a lot more like the mathematical expressions!</p></div></div><p>Next, we define our set of differential equations. To define the <code>Differential</code> operator <code>D</code>, we need to first tell it what to differentiate with respect to, here the independent variable <code>t</code>, Then, once we have the operator, we apply that into the equations.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that in ModelingToolkit and Symbolics, <code>~</code> is used for equation equality. This is separate from <code>=</code> which is the ‚Äúassignment operator‚Äù in the Julia programming language. For example, <code>x = x + 1</code> is a valid assignment in a programming language, and it is invalid for that to represent ‚Äúequality‚Äù, which is why a separate operator is used!</p></div></div><pre><code class="language-julia hljs"># Define our differential: takes the derivative with respect to `t`
D = Differential(t)

# Define the differential equations
eqs = [D(x) ~ Œ± * x - Œ≤ * x * y
       D(y) ~ -Œ≥ * y + Œ¥ * x * y
       z ~ x + y]</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; x\left( t \right) \alpha - x\left( t \right) y\left( t \right) \beta \\
\frac{\mathrm{d} y\left( t \right)}{\mathrm{d}t} =&amp;  - y\left( t \right) \gamma + x\left( t \right) y\left( t \right) \delta \\
z\left( t \right) =&amp; x\left( t \right) + y\left( t \right)
\end{align}
 \]</p><p>Notice that in the display, it will automatically generate LaTeX. If one is interested in generating this LaTeX locally, one can simply do:</p><pre><code class="language-julia hljs">using Latexify # add the package first
latexify(eqs)</code></pre><h2 id="Step-3:-Define-the-ODEProblem"><a class="docs-heading-anchor" href="#Step-3:-Define-the-ODEProblem">Step 3: Define the ODEProblem</a><a id="Step-3:-Define-the-ODEProblem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Define-the-ODEProblem" title="Permalink"></a></h2><p>Now we bring these pieces together. In ModelingToolkit, we can bring these pieces together to represent an <code>ODESystem</code> with the following:</p><pre><code class="language-julia hljs"># Bring these pieces together into an ODESystem with independent variable t
@named sys = ODESystem(eqs, t)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; x\left( t \right) \alpha - x\left( t \right) y\left( t \right) \beta \\
\frac{\mathrm{d} y\left( t \right)}{\mathrm{d}t} =&amp;  - y\left( t \right) \gamma + x\left( t \right) y\left( t \right) \delta \\
z\left( t \right) =&amp; x\left( t \right) + y\left( t \right)
\end{align}
 \]</p><p>Next, we want to simplify this into a standard ODE system. Notice that in our equations we have an algebraic equation <code>z ~ x + y</code>. This is not a differential equation but an algebraic equation, and thus we call this set of equations a Differential-Algebraic Equation (DAE). The symbolic system of ModelingToolkit can eliminate such equations to return simpler forms to numerically approximate. Let&#39;s tell it to simplify the system using <code>structural_simplify</code>:</p><pre><code class="language-julia hljs"># Symbolically Simplify the System
simpsys = structural_simplify(sys)</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d} x\left( t \right)}{\mathrm{d}t} =&amp; x\left( t \right) \alpha - x\left( t \right) y\left( t \right) \beta \\
\frac{\mathrm{d} y\left( t \right)}{\mathrm{d}t} =&amp;  - y\left( t \right) \gamma + x\left( t \right) y\left( t \right) \delta
\end{align}
 \]</p><p>Notice that what is returned is another <code>ODESystem</code>, but now with the simplified set of equations. <code>z</code> has been turned into an ‚Äúobservable‚Äù, i.e. a state that is not computed but can be constructed on-demand. This is one of the ways that SciML reaches its speed: you can have 100,000 equations, but solve only 1,000 to then automatically reconstruct the full set. Here, it&#39;s just 3 equations to 2, but as models get more complex, the symbolic system will find ever more clever interactions!</p><p>Now that we have simplified our system, let&#39;s turn it into a numerical problem to approximate. This is done with the <code>ODEProblem</code> constructor, that transforms it from a symbolic <code>ModelingToolkit</code> representation to a numerical <code>DifferentialEquations</code> representation. We need to tell it the numerical details now:</p><ol><li>Whether to override any of the default values for the initial conditions and parameters.</li><li>What is the initial time point.</li><li>How long to integrate it for.</li></ol><p>In this case, we will use the default values for all our variables, so we will pass a blank override <code>[]</code>. If for example we did want to change the initial condition of <code>x</code> to <code>2.0</code> and <code>Œ±</code> to <code>4.0</code>, we would do <code>[x =&gt; 2.0, Œ± =&gt; 4.0]</code>. Then secondly, we pass a tuple for the time span, <code>(0.0,10.0)</code> meaning start at <code>0.0</code> and end at <code>10.0</code>. This looks like:</p><pre><code class="language-julia hljs"># Convert from a symbolic to a numerical problem to simulate
tspan = (0.0, 10.0)
prob = ODEProblem(simpsys, [], tspan)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr38_2" style="color:#56b6c2">ODEProblem</span> with uType <span class="sgr38_2" style="color:#56b6c2">Vector{Float64}</span> and tType <span class="sgr38_2" style="color:#56b6c2">Float64</span>. In-place: <span class="sgr38_2" style="color:#56b6c2">true</span>
timespan: (0.0, 10.0)
u0: 2-element Vector{Float64}:
 1.0
 1.0</code></pre><h3 id="Step-4:-Solve-the-ODE-System"><a class="docs-heading-anchor" href="#Step-4:-Solve-the-ODE-System">Step 4: Solve the ODE System</a><a id="Step-4:-Solve-the-ODE-System-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Solve-the-ODE-System" title="Permalink"></a></h3><p>Now we solve the ODE system. Julia&#39;s SciML solvers have a defaulting system that can automatically determine an appropriate solver for a given system, so we can just tell it to solve:</p><pre><code class="language-julia hljs"># Solve the ODE
sol = solve(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation, specialized 2nd order &quot;free&quot; stiffness-aware interpolation
t: 34-element Vector{Float64}:
  0.0
  0.0776084743154256
  0.23264513699277584
  0.4291185174543143
  0.6790821987497083
  0.9444046158046306
  1.2674601546021105
  1.6192913303893046
  1.9869754428624007
  2.2640902393538296
  ‚ãÆ
  7.584863345264154
  7.978068981329682
  8.48316543760351
  8.719248247740158
  8.949206788834692
  9.200185054623292
  9.438029017301554
  9.711808134779586
 10.0
u: 34-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [1.0454942346944578, 0.8576684823217127]
 [1.1758715885138267, 0.639459570317544]
 [1.4196809607170826, 0.4569962601282084]
 [1.876719395008001, 0.32473342927911314]
 [2.5882500645533466, 0.26336255535952163]
 [3.8607089092207665, 0.2794458098285253]
 [5.750812667710396, 0.5220072537934558]
 [6.814978999130169, 1.9177826328390666]
 [4.3929992925714245, 4.194670792850584]
 ‚ãÆ
 [2.614253967788294, 0.26416945387525886]
 [4.241076127191749, 0.3051236762921916]
 [6.791123785297795, 1.1345287797146113]
 [6.265370675764892, 2.74169350754023]
 [3.7807651118880545, 4.431165685863461]
 [1.816420140681761, 4.064056625315978]
 [1.1465021407690728, 2.7911706616216976]
 [0.9557986135403302, 1.6235622951850799]
 [1.0337581256020607, 0.9063703842886133]</code></pre><h3 id="Step-5:-Visualize-the-Solution"><a class="docs-heading-anchor" href="#Step-5:-Visualize-the-Solution">Step 5: Visualize the Solution</a><a id="Step-5:-Visualize-the-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Visualize-the-Solution" title="Permalink"></a></h3><p>Now let&#39;s visualize the solution! Notice that our solution only has two states. If we recall, the simplified system only has two states: <code>z</code> was symbolically eliminated. We can access any of the values, even the eliminated values, using the symbolic variable as the index. For example:</p><pre><code class="language-julia hljs">sol[z]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">34-element Vector{Float64}:
 2.0
 1.9031627170161705
 1.8153311588313708
 1.8766772208452909
 2.2014528242871143
 2.8516126199128684
 4.140154719049292
 6.272819921503852
 8.732761631969236
 8.587670085422008
 ‚ãÆ
 2.878423421663553
 4.54619980348394
 7.925652565012406
 9.007064183305122
 8.211930797751515
 5.88047676599774
 3.9376728023907703
 2.57936090872541
 1.940128509890674</code></pre><p>returns the time series of the observable <code>z</code> at time points corresponding to <code>sol.t</code>. We can use this with the automated plotting functionality. First let&#39;s create a plot of <code>x</code> and <code>y</code> over time using <code>plot(sol)</code> which will plot all of the states. Then next, we will explicitly tell it to make a plot with the index being <code>z</code>, i.e. <code>idxs=z</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Note that one can pass an array of indices as well, so <code>idxs=[x,y,z]</code> would make a plot with all three lines together!</p></div></div><pre><code class="language-julia hljs"># Plot the solution
p1 = plot(sol, title = &quot;Rabbits vs Wolves&quot;)</code></pre><img src="c2447471.svg" alt="Example block output"/><pre><code class="language-julia hljs">p2 = plot(sol, idxs = z, title = &quot;Total Animals&quot;)</code></pre><img src="5215eff6.svg" alt="Example block output"/><p>Finally, let&#39;s make a plot where we merge these two plot elements. To do so, we can take our two plot objects, <code>p1</code> and <code>p2</code>, and make a plot with both of them. Then we tell Plots to do a layout of <code>(2,1)</code>, or 2 rows and 1 columns. Let&#39;s see what happens when we bring these together:</p><pre><code class="language-julia hljs">plot(p1, p2, layout = (2, 1))</code></pre><img src="84eab29a.svg" alt="Example block output"/><p>And tada, we have a full analysis of our ecosystem!</p><h2 id="Bonus-Step:-Emoji-Variables"><a class="docs-heading-anchor" href="#Bonus-Step:-Emoji-Variables">Bonus Step: Emoji Variables</a><a id="Bonus-Step:-Emoji-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Bonus-Step:-Emoji-Variables" title="Permalink"></a></h2><p>If you made it this far, then congrats, you get to learn a fun fact! Since Julia code can use Unicode, emojis work for variable names. Here&#39;s the simulation using emojis of rabbits and wolves to define the system:</p><pre><code class="language-julia hljs">using ModelingToolkit, DifferentialEquations
@parameters Œ±=1.5 Œ≤=1.0 Œ≥=3.0 Œ¥=1.0
@variables t üê∞(t)=1.0 üê∫(t)=1.0
D = Differential(t)
eqs = [D(üê∞) ~ Œ± * üê∞ - Œ≤ * üê∞ * üê∫,
    D(üê∫) ~ -Œ≥ * üê∫ + Œ¥ * üê∞ * üê∫]

@named sys = ODESystem(eqs, t)
simpsys = structural_simplify(sys)
prob = ODEProblem(simpsys, [], (0.0, 10.0))
sol = solve(prob)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Success
Interpolation: specialized 4th order &quot;free&quot; interpolation, specialized 2nd order &quot;free&quot; stiffness-aware interpolation
t: 34-element Vector{Float64}:
  0.0
  0.0776084743154256
  0.23264513699277584
  0.4291185174543143
  0.6790821987497083
  0.9444046158046306
  1.2674601546021105
  1.6192913303893046
  1.9869754428624007
  2.2640902393538296
  ‚ãÆ
  7.584863345264154
  7.978068981329682
  8.48316543760351
  8.719248247740158
  8.949206788834692
  9.200185054623292
  9.438029017301554
  9.711808134779586
 10.0
u: 34-element Vector{Vector{Float64}}:
 [1.0, 1.0]
 [1.0454942346944578, 0.8576684823217127]
 [1.1758715885138267, 0.639459570317544]
 [1.4196809607170826, 0.4569962601282084]
 [1.876719395008001, 0.32473342927911314]
 [2.5882500645533466, 0.26336255535952163]
 [3.8607089092207665, 0.2794458098285253]
 [5.750812667710396, 0.5220072537934558]
 [6.814978999130169, 1.9177826328390666]
 [4.3929992925714245, 4.194670792850584]
 ‚ãÆ
 [2.614253967788294, 0.26416945387525886]
 [4.241076127191749, 0.3051236762921916]
 [6.791123785297795, 1.1345287797146113]
 [6.265370675764892, 2.74169350754023]
 [3.7807651118880545, 4.431165685863461]
 [1.816420140681761, 4.064056625315978]
 [1.1465021407690728, 2.7911706616216976]
 [0.9557986135403302, 1.6235622951850799]
 [1.0337581256020607, 0.9063703842886133]</code></pre><p>Now go make your professor mad that they have to grade a fully emojified code. I&#39;ll vouch for you: the documentation told you to do this.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../installation/">¬´ Installing SciML Software</a><a class="docs-footer-nextpage" href="../first_optimization/">Solve your first optimization problem ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.1.1 on <span class="colophon-date" title="Wednesday 18 October 2023 10:30">Wednesday 18 October 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
