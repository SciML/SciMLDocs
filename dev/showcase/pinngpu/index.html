<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers Â· Overview of Julia&#39;s SciML</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/stable/showcase/pinngpu/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/installation/">Installing SciML Software</a></li><li><a class="tocitem" href="../../getting_started/first_simulation/">Build and run your first simulation with Julia&#39;s SciML</a></li><li><a class="tocitem" href="../../getting_started/first_optimization/">Solve your first optimization problem</a></li><li><a class="tocitem" href="../../getting_started/fit_simulation/">Fit a simulation to a dataset</a></li><li><a class="tocitem" href="../../getting_started/find_root/">Find the root of an equation (i.e. solve f(u)=0)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../comparisons/python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../../comparisons/matlab/">Getting Started with  Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../../comparisons/r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li><a class="tocitem" href="../../comparisons/cppfortran/">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../missing_physics/">Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a></li><li><a class="tocitem" href="../bayesian_neural_ode/">Uncertainty Quantified Deep Bayesian Model Discovery</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox" checked/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li class="is-active"><a class="tocitem" href>GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a><ul class="internal"><li><a class="tocitem" href="#Step-1:-Import-Libraries"><span>Step 1: Import Libraries</span></a></li><li><a class="tocitem" href="#Problem-Setup"><span>Problem Setup</span></a></li><li><a class="tocitem" href="#Step-2:-Define-the-PDESystem"><span>Step 2: Define the PDESystem</span></a></li><li><a class="tocitem" href="#Step-3:-Define-the-Lux-Neural-Network"><span>Step 3: Define the Lux Neural Network</span></a></li><li><a class="tocitem" href="#Step-4:-Place-it-on-the-GPU."><span>Step 4: Place it on the GPU.</span></a></li><li><a class="tocitem" href="#Step-5:-Discretize-the-PDE-via-a-PINN-Training-Strategy"><span>Step 5: Discretize the PDE via a PINN Training Strategy</span></a></li><li><a class="tocitem" href="#Step-6:-Solve-the-Optimization-Problem"><span>Step 6: Solve the Optimization Problem</span></a></li><li><a class="tocitem" href="#Step-7:-Inspect-the-PINN&#39;s-Solution"><span>Step 7: Inspect the PINN&#39;s Solution</span></a></li></ul></li><li><a class="tocitem" href="../massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li><li><a class="tocitem" href="../gpu_spde/">GPU-Accelerated Stochastic Partial Differential Equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ode_types/">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li><li><a class="tocitem" href="../symbolic_analysis/">Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/equation_solvers/">Equation Solvers</a></li><li><a class="tocitem" href="../../highlevels/inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li><li><a class="tocitem" href="../../highlevels/partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../../highlevels/model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../../highlevels/symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../../highlevels/array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../../highlevels/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../highlevels/plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../../highlevels/implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../../highlevels/symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../../highlevels/interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../../highlevels/developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Showcase of Cool Examples</a></li><li><a class="is-disabled">Solving Difficult Equations Efficiently</a></li><li class="is-active"><a href>GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/showcase/pinngpu.md" title="Edit on GitHub"><span class="docs-icon fab">ï‚›</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="pinngpu"><a class="docs-heading-anchor" href="#pinngpu">GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a><a id="pinngpu-1"></a><a class="docs-heading-anchor-permalink" href="#pinngpu" title="Permalink"></a></h1><p>Machine learning is all the rage. Everybody thinks physics is cool.</p><p>Therefore, using machine learning to solve physics equations? ðŸ§ ðŸ’¥</p><p>So let&#39;s be cool and use a physics-informed neural network (PINN) to solve the Heat Equation. Let&#39;s be even cooler by using GPUs (ironically, creating even more heat, but it&#39;s the heat equation so that&#39;s cool).</p><h2 id="Step-1:-Import-Libraries"><a class="docs-heading-anchor" href="#Step-1:-Import-Libraries">Step 1: Import Libraries</a><a id="Step-1:-Import-Libraries-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Import-Libraries" title="Permalink"></a></h2><p>To solve PDEs using neural networks, we will use the <a href="https://neuralpde.sciml.ai/stable/">NeuralPDE.jl package</a>. This package uses ModelingToolkit&#39;s symbolic <code>PDESystem</code> as an input, and it generates an <a href="https://docs.sciml.ai/Optimization/stable/">Optimization.jl</a> <code>OptimizationProblem</code> which, when solved, gives the weights of the neural network that solve the PDE. In the end, our neural network <code>NN</code> satisfies the PDE equations and is thus the solution to the PDE! Thus our packages look like:</p><pre><code class="language-julia hljs">using NeuralPDE
using Optimization, OptimizationOptimisers
import ModelingToolkit: Interval
using Plots, Printf, Lux, CUDA, Random</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">WARNING: Method definition rrule(Type{Array{T, N} where N where T}, CUDA.CuArray{T, N, B} where B where N where T) in module Flux at /root/.cache/julia-buildkite-plugin/depots/0183cc98-c3b4-4959-aaaa-6c0d5f351407/packages/Flux/v79Am/src/functor.jl:125 overwritten in module Lux at /root/.cache/julia-buildkite-plugin/depots/0183cc98-c3b4-4959-aaaa-6c0d5f351407/packages/Lux/6vByk/src/autodiff.jl:57.
  ** incremental compilation may be fatally broken for this module **

WARNING: method definition for PhysicsInformedNN#4 at /root/.cache/julia-buildkite-plugin/depots/0183cc98-c3b4-4959-aaaa-6c0d5f351407/packages/NeuralPDE/TKBZR/src/pinn_types.jl:97 declares type variable iip but does not use it.
WARNING: method definition for PhysicsInformedNN#5 at /root/.cache/julia-buildkite-plugin/depots/0183cc98-c3b4-4959-aaaa-6c0d5f351407/packages/NeuralPDE/TKBZR/src/pinn_types.jl:97 declares type variable iip but does not use it.</code></pre><h2 id="Problem-Setup"><a class="docs-heading-anchor" href="#Problem-Setup">Problem Setup</a><a id="Problem-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Setup" title="Permalink"></a></h2><p>Let&#39;s solve the 2+1-dimensional Heat Equation. This is the PDE:</p><p class="math-container">\[âˆ‚_t u(x, y, t) = âˆ‚^2_x u(x, y, t) + âˆ‚^2_y u(x, y, t) \, ,\]</p><p>with the initial and boundary conditions:</p><p class="math-container">\[\begin{align*}
u(x, y, 0) &amp;= e^{x+y} \cos(x + y)      \, ,\\
u(0, y, t) &amp;= e^{y}   \cos(y + 4t)     \, ,\\
u(2, y, t) &amp;= e^{2+y} \cos(2 + y + 4t) \, ,\\
u(x, 0, t) &amp;= e^{x}   \cos(x + 4t)     \, ,\\
u(x, 2, t) &amp;= e^{x+2} \cos(x + 2 + 4t) \, ,
\end{align*}\]</p><p>on the space and time domain:</p><p class="math-container">\[x \in [0, 2] \, ,\ y \in [0, 2] \, , \ t \in [0, 2] \, ,\]</p><p>with physics-informed neural networks.</p><h2 id="Step-2:-Define-the-PDESystem"><a class="docs-heading-anchor" href="#Step-2:-Define-the-PDESystem">Step 2: Define the PDESystem</a><a id="Step-2:-Define-the-PDESystem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-2:-Define-the-PDESystem" title="Permalink"></a></h2><p>First, let&#39;s use ModelingToolkit&#39;s <code>PDESystem</code> to represent the PDE. To do this, basically just copy-paste the PDE definition into Julia code. This looks like:</p><pre><code class="language-julia hljs">@parameters t x y
@variables u(..)
Dxx = Differential(x)^2
Dyy = Differential(y)^2
Dt = Differential(t)
t_min = 0.0
t_max = 2.0
x_min = 0.0
x_max = 2.0
y_min = 0.0
y_max = 2.0

# 2D PDE
eq = Dt(u(t, x, y)) ~ Dxx(u(t, x, y)) + Dyy(u(t, x, y))

analytic_sol_func(t, x, y) = exp(x + y) * cos(x + y + 4t)
# Initial and boundary conditions
bcs = [u(t_min, x, y) ~ analytic_sol_func(t_min, x, y),
    u(t, x_min, y) ~ analytic_sol_func(t, x_min, y),
    u(t, x_max, y) ~ analytic_sol_func(t, x_max, y),
    u(t, x, y_min) ~ analytic_sol_func(t, x, y_min),
    u(t, x, y_max) ~ analytic_sol_func(t, x, y_max)]

# Space and time domains
domains = [t âˆˆ Interval(t_min, t_max),
    x âˆˆ Interval(x_min, x_max),
    y âˆˆ Interval(y_min, y_max)]

@named pde_system = PDESystem(eq, bcs, domains, [t, x, y], [u(t, x, y)])</code></pre><p class="math-container">\[ \begin{align}
\frac{\mathrm{d}}{\mathrm{d}t} u\left( t, x, y \right) =&amp; \frac{\mathrm{d}^{2}}{\mathrm{d}x^{2}} u\left( t, x, y \right) + \frac{\mathrm{d}^{2}}{\mathrm{d}y^{2}} u\left( t, x, y \right)
\end{align}
 \]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We used the wildcard form of the variable definition <code>@variables u(..)</code> which then requires that we always specify what the dependent variables of <code>u</code> are. This is because in the boundary conditions we change from using <code>u(t,x,y)</code> to more specific points and lines, like <code>u(t,x_max,y)</code>.</p></div></div><h2 id="Step-3:-Define-the-Lux-Neural-Network"><a class="docs-heading-anchor" href="#Step-3:-Define-the-Lux-Neural-Network">Step 3: Define the Lux Neural Network</a><a id="Step-3:-Define-the-Lux-Neural-Network-1"></a><a class="docs-heading-anchor-permalink" href="#Step-3:-Define-the-Lux-Neural-Network" title="Permalink"></a></h2><p>Now let&#39;s define the neural network that will act as our solution. We will use a simple multi-layer perceptron, like:</p><pre><code class="language-julia hljs">using Lux
inner = 25
chain = Chain(Dense(3, inner, Lux.Ïƒ),
              Dense(inner, inner, Lux.Ïƒ),
              Dense(inner, inner, Lux.Ïƒ),
              Dense(inner, inner, Lux.Ïƒ),
              Dense(inner, 1))
ps = Lux.setup(Random.default_rng(), chain)[1]
ps = ps |&gt; Lux.ComponentArray</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentVector{Float32}(layer_1 = (weight = Float32[0.4141928 0.050716653 0.057718128; 0.13120915 0.13882007 0.1312571; â€¦ ; -0.08489303 0.45626643 -0.07733751; -0.15552585 -0.31606883 0.3339687], bias = Float32[0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_2 = (weight = Float32[-0.20258 0.17021406 â€¦ 0.107008204 -0.22217755; -0.16384587 -0.14429612 â€¦ 0.036387566 0.12626189; â€¦ ; -0.1913414 0.2768816 â€¦ 0.21091595 0.25125068; 0.11863903 0.022580894 â€¦ 0.27641964 0.2748139], bias = Float32[0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_3 = (weight = Float32[-0.21297815 -0.34031093 â€¦ 0.056620825 -0.20035835; -0.07562026 -0.0960578 â€¦ 0.13647175 -0.18159322; â€¦ ; -0.008388274 0.31465983 â€¦ 0.02173851 -0.16221796; 0.06357363 0.28935605 â€¦ 0.33557504 0.075664446], bias = Float32[0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_4 = (weight = Float32[-0.10794263 -0.25360948 â€¦ -0.15135871 0.030796224; 0.23032074 0.112397775 â€¦ 0.27814996 -0.21961795; â€¦ ; -0.27462944 -0.28611922 â€¦ -0.0031432337 0.34351993; 0.18313214 -0.28702402 â€¦ -0.23521395 0.06363789], bias = Float32[0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_5 = (weight = Float32[-0.30514786 -0.34494483 â€¦ 0.12511316 0.25433323], bias = Float32[0.0;;]))</code></pre><h2 id="Step-4:-Place-it-on-the-GPU."><a class="docs-heading-anchor" href="#Step-4:-Place-it-on-the-GPU.">Step 4: Place it on the GPU.</a><a id="Step-4:-Place-it-on-the-GPU.-1"></a><a class="docs-heading-anchor-permalink" href="#Step-4:-Place-it-on-the-GPU." title="Permalink"></a></h2><p>Just plop it on that sucker. We must ensure that our initial parameters for the neural network are on the GPU. If that is done, then the internal computations will all take place on the GPU. This is done by using the <code>gpu</code> function on the initial parameters, like:</p><pre><code class="language-julia hljs">ps = ps |&gt; gpu .|&gt; Float64</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">ComponentArrays.ComponentVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Tuple{ComponentArrays.Axis{(layer_1 = ViewAxis(1:100, Axis(weight = ViewAxis(1:75, ShapedAxis((25, 3), NamedTuple())), bias = ViewAxis(76:100, ShapedAxis((25, 1), NamedTuple())))), layer_2 = ViewAxis(101:750, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_3 = ViewAxis(751:1400, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_4 = ViewAxis(1401:2050, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_5 = ViewAxis(2051:2076, Axis(weight = ViewAxis(1:25, ShapedAxis((1, 25), NamedTuple())), bias = ViewAxis(26:26, ShapedAxis((1, 1), NamedTuple())))))}}}(layer_1 = (weight = [0.414192795753479 0.05071665346622467 0.057718127965927124; 0.13120914995670319 0.13882006704807281 0.131257101893425; â€¦ ; -0.08489303290843964 0.4562664330005646 -0.07733751088380814; -0.15552584826946259 -0.3160688281059265 0.3339686989784241], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_2 = (weight = [-0.20258000493049622 0.17021405696868896 â€¦ 0.1070082038640976 -0.22217755019664764; -0.16384586691856384 -0.14429612457752228 â€¦ 0.03638756647706032 0.1262618899345398; â€¦ ; -0.19134140014648438 0.276881605386734 â€¦ 0.2109159529209137 0.251250684261322; 0.1186390295624733 0.022580893710255623 â€¦ 0.27641963958740234 0.2748138904571533], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_3 = (weight = [-0.21297815442085266 -0.3403109312057495 â€¦ 0.056620825082063675 -0.2003583461046219; -0.07562025636434555 -0.09605780243873596 â€¦ 0.13647174835205078 -0.18159322440624237; â€¦ ; -0.008388274349272251 0.31465983390808105 â€¦ 0.021738510578870773 -0.16221795976161957; 0.06357362866401672 0.2893560528755188 â€¦ 0.33557504415512085 0.0756644457578659], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_4 = (weight = [-0.10794263333082199 -0.25360947847366333 â€¦ -0.1513587087392807 0.030796224251389503; 0.2303207367658615 0.11239777505397797 â€¦ 0.27814996242523193 -0.21961794793605804; â€¦ ; -0.2746294438838959 -0.2861192226409912 â€¦ -0.0031432337127625942 0.343519926071167; 0.183132141828537 -0.28702402114868164 â€¦ -0.23521395027637482 0.06363788992166519], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_5 = (weight = [-0.30514785647392273 -0.3449448347091675 â€¦ 0.12511315941810608 0.2543332278728485], bias = [0.0;;]))</code></pre><h2 id="Step-5:-Discretize-the-PDE-via-a-PINN-Training-Strategy"><a class="docs-heading-anchor" href="#Step-5:-Discretize-the-PDE-via-a-PINN-Training-Strategy">Step 5: Discretize the PDE via a PINN Training Strategy</a><a id="Step-5:-Discretize-the-PDE-via-a-PINN-Training-Strategy-1"></a><a class="docs-heading-anchor-permalink" href="#Step-5:-Discretize-the-PDE-via-a-PINN-Training-Strategy" title="Permalink"></a></h2><pre><code class="language-julia hljs">strategy = GridTraining(0.05)
discretization = PhysicsInformedNN(chain,
                                   strategy,
                                   init_params = ps)
prob = discretize(pde_system, discretization)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">OptimizationProblem. In-place: true
u0: ComponentArrays.ComponentVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Tuple{ComponentArrays.Axis{(layer_1 = ViewAxis(1:100, Axis(weight = ViewAxis(1:75, ShapedAxis((25, 3), NamedTuple())), bias = ViewAxis(76:100, ShapedAxis((25, 1), NamedTuple())))), layer_2 = ViewAxis(101:750, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_3 = ViewAxis(751:1400, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_4 = ViewAxis(1401:2050, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_5 = ViewAxis(2051:2076, Axis(weight = ViewAxis(1:25, ShapedAxis((1, 25), NamedTuple())), bias = ViewAxis(26:26, ShapedAxis((1, 1), NamedTuple())))))}}}(layer_1 = (weight = [0.414192795753479 0.05071665346622467 0.057718127965927124; 0.13120914995670319 0.13882006704807281 0.131257101893425; â€¦ ; -0.08489303290843964 0.4562664330005646 -0.07733751088380814; -0.15552584826946259 -0.3160688281059265 0.3339686989784241], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_2 = (weight = [-0.20258000493049622 0.17021405696868896 â€¦ 0.1070082038640976 -0.22217755019664764; -0.16384586691856384 -0.14429612457752228 â€¦ 0.03638756647706032 0.1262618899345398; â€¦ ; -0.19134140014648438 0.276881605386734 â€¦ 0.2109159529209137 0.251250684261322; 0.1186390295624733 0.022580893710255623 â€¦ 0.27641963958740234 0.2748138904571533], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_3 = (weight = [-0.21297815442085266 -0.3403109312057495 â€¦ 0.056620825082063675 -0.2003583461046219; -0.07562025636434555 -0.09605780243873596 â€¦ 0.13647174835205078 -0.18159322440624237; â€¦ ; -0.008388274349272251 0.31465983390808105 â€¦ 0.021738510578870773 -0.16221795976161957; 0.06357362866401672 0.2893560528755188 â€¦ 0.33557504415512085 0.0756644457578659], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_4 = (weight = [-0.10794263333082199 -0.25360947847366333 â€¦ -0.1513587087392807 0.030796224251389503; 0.2303207367658615 0.11239777505397797 â€¦ 0.27814996242523193 -0.21961794793605804; â€¦ ; -0.2746294438838959 -0.2861192226409912 â€¦ -0.0031432337127625942 0.343519926071167; 0.183132141828537 -0.28702402114868164 â€¦ -0.23521395027637482 0.06363788992166519], bias = [0.0; 0.0; â€¦ ; 0.0; 0.0;;]), layer_5 = (weight = [-0.30514785647392273 -0.3449448347091675 â€¦ 0.12511315941810608 0.2543332278728485], bias = [0.0;;]))</code></pre><h2 id="Step-6:-Solve-the-Optimization-Problem"><a class="docs-heading-anchor" href="#Step-6:-Solve-the-Optimization-Problem">Step 6: Solve the Optimization Problem</a><a id="Step-6:-Solve-the-Optimization-Problem-1"></a><a class="docs-heading-anchor-permalink" href="#Step-6:-Solve-the-Optimization-Problem" title="Permalink"></a></h2><pre><code class="language-julia hljs">callback = function (p, l)
    println(&quot;Current loss is: $l&quot;)
    return false
end

res = Optimization.solve(prob, Adam(0.01); callback = callback, maxiters = 2500);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: ComponentArrays.ComponentVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Tuple{ComponentArrays.Axis{(layer_1 = ViewAxis(1:100, Axis(weight = ViewAxis(1:75, ShapedAxis((25, 3), NamedTuple())), bias = ViewAxis(76:100, ShapedAxis((25, 1), NamedTuple())))), layer_2 = ViewAxis(101:750, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_3 = ViewAxis(751:1400, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_4 = ViewAxis(1401:2050, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_5 = ViewAxis(2051:2076, Axis(weight = ViewAxis(1:25, ShapedAxis((1, 25), NamedTuple())), bias = ViewAxis(26:26, ShapedAxis((1, 1), NamedTuple())))))}}}(layer_1 = (weight = [-1.1005115014332845 -0.17942247115146762 -0.1448999471846391; -0.6222837216507879 -0.42821687504521105 -0.4054804519177524; â€¦ ; 3.7330342730689656 0.8694538371056842 -0.15202140290492824; -1.1544242752510518 -0.3819223865126167 -0.35315572153364483], bias = [1.9985067878152991; 1.3746711679617711; â€¦ ; -0.5189502756561798; 1.2278600218279687;;]), layer_2 = (weight = [1.5209021912986578 1.3286912985121984 â€¦ 0.22853211844141136 0.47726282512585144; -0.39034397049832914 0.6842109429180299 â€¦ -0.5505147814457684 1.1864313578161525; â€¦ ; -2.5541527891919134 -2.6144155022090376 â€¦ 0.06936118468223135 -1.7124721409319517; 1.0713887846847534 2.1738002245476484 â€¦ -0.5991336301507754 2.7728164400827477], bias = [-0.004081953296585746; 0.29369990548946623; â€¦ ; -0.10894208279953924; -0.1598102615964235;;]), layer_3 = (weight = [1.010980063793496 -1.7633696526514928 â€¦ -1.5613357270822406 0.4695522704212663; 0.26291882626754864 -0.0670063346785697 â€¦ 1.8310260217190073 -1.0446916897010547; â€¦ ; 1.3854974832296405 -1.0726011692525315 â€¦ -2.146918919188163 0.5791571820572146; 0.9874064971754463 -1.3636899009802483 â€¦ -1.5351750413729772 0.021683478228451136], bias = [-0.15448970937379133; -0.028850062271583488; â€¦ ; -0.26459901463063157; -0.08414100421931495;;]), layer_4 = (weight = [0.3371163894786762 -2.991532807646077 â€¦ 0.5885182675097793 0.6992229895805506; 0.5872073809422392 -3.1189879939436773 â€¦ 1.0054278315043077 -0.006037368430240223; â€¦ ; -1.488515777995328 3.178794051573554 â€¦ -1.5716865170984315 0.08339915094755228; -0.3603251892930828 2.9103165260854347 â€¦ -0.7226253296489614 -0.2770896372513157], bias = [-2.1399330001909345; -2.751298807539184; â€¦ ; 3.424227075862466; 2.522132915274614;;]), layer_5 = (weight = [-4.992284168580358 -4.1971089859138635 â€¦ 8.110728680207773 6.789571532715832], bias = [0.45580665645272955;;]))</code></pre><p>We then use the <code>remake</code> function to rebuild the PDE problem to start a new optimization at the optimized parameters, and continue with a lower learning rate:</p><pre><code class="language-julia hljs">prob = remake(prob, u0 = res.u)
res = Optimization.solve(prob, Adam(0.001); callback = callback, maxiters = 2500);</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">u: ComponentArrays.ComponentVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Tuple{ComponentArrays.Axis{(layer_1 = ViewAxis(1:100, Axis(weight = ViewAxis(1:75, ShapedAxis((25, 3), NamedTuple())), bias = ViewAxis(76:100, ShapedAxis((25, 1), NamedTuple())))), layer_2 = ViewAxis(101:750, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_3 = ViewAxis(751:1400, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_4 = ViewAxis(1401:2050, Axis(weight = ViewAxis(1:625, ShapedAxis((25, 25), NamedTuple())), bias = ViewAxis(626:650, ShapedAxis((25, 1), NamedTuple())))), layer_5 = ViewAxis(2051:2076, Axis(weight = ViewAxis(1:25, ShapedAxis((1, 25), NamedTuple())), bias = ViewAxis(26:26, ShapedAxis((1, 1), NamedTuple())))))}}}(layer_1 = (weight = [-1.1151974717331248 -0.17532449641207598 -0.1432703328773516; -0.5896120671682802 -0.4259970405238005 -0.40897934216238674; â€¦ ; 3.749331344488322 0.7199976279726225 -0.05559938644681577; -1.2604771969268969 -0.4186874446115659 -0.37574231283367765], bias = [2.0087053681033886; 1.3806935289718356; â€¦ ; -0.5390016714155574; 1.1699702319150302;;]), layer_2 = (weight = [1.5198508690202541 1.330072442604076 â€¦ 0.22132037545795116 0.4829286618177629; -0.39625216384720535 0.6823899578817543 â€¦ -0.5395833106859221 1.1867577044302204; â€¦ ; -2.575416852646836 -2.654105341040641 â€¦ 0.05892552392992548 -1.7406899219414103; 0.9936860678564295 2.1483082636706126 â€¦ -0.5899962166933119 2.6681754453753297], bias = [-0.009854622957662826; 0.3009567144834339; â€¦ ; -0.11623410410495513; -0.14871127150171085;;]), layer_3 = (weight = [1.0150443358754175 -1.766957299202703 â€¦ -1.6396756325280943 0.47337423269022216; 0.246566969631665 -0.07578352079813709 â€¦ 2.0580795653657025 -1.0267603598167399; â€¦ ; 1.391103575780352 -1.074633993965362 â€¦ -2.2660853415369373 0.5759131297946651; 1.0549013566492298 -1.3110023017459127 â€¦ -1.6305281125692155 0.0010001005088860289], bias = [-0.15976629034787113; -0.035214329252705526; â€¦ ; -0.27135644871709796; -0.0402495590330084;;]), layer_4 = (weight = [0.3298285940392023 -3.0736093983661443 â€¦ 0.5885138627952634 0.7367335892677213; 0.543731117373996 -3.1564009755437863 â€¦ 0.9847430630401544 -0.0693543148198827; â€¦ ; -1.4965479036001137 3.246326414649074 â€¦ -1.5765404860356391 0.2125449131258787; -0.327940406521398 2.938130132257743 â€¦ -0.6722584449066679 -0.2800934031221893], bias = [-2.186798730670791; -2.81191523408506; â€¦ ; 3.5765217708632; 2.5417424499919474;;]), layer_5 = (weight = [-5.11680123313505 -4.348271368654691 â€¦ 8.747087765978122 7.073798587419124], bias = [0.4600211310947522;;]))</code></pre><h2 id="Step-7:-Inspect-the-PINN&#39;s-Solution"><a class="docs-heading-anchor" href="#Step-7:-Inspect-the-PINN&#39;s-Solution">Step 7: Inspect the PINN&#39;s Solution</a><a id="Step-7:-Inspect-the-PINN&#39;s-Solution-1"></a><a class="docs-heading-anchor-permalink" href="#Step-7:-Inspect-the-PINN&#39;s-Solution" title="Permalink"></a></h2><p>Finally, we inspect the solution:</p><pre><code class="language-julia hljs">phi = discretization.phi
ts, xs, ys = [infimum(d.domain):0.1:supremum(d.domain) for d in domains]
u_real = [analytic_sol_func(t, x, y) for t in ts for x in xs for y in ys]
u_predict = [first(Array(phi(gpu([t, x, y]), res.u))) for t in ts for x in xs for y in ys]

function plot_(res)
    # Animate
    anim = @animate for (i, t) in enumerate(0:0.05:t_max)
        @info &quot;Animating frame $i...&quot;
        u_real = reshape([analytic_sol_func(t, x, y) for x in xs for y in ys],
                         (length(xs), length(ys)))
        u_predict = reshape([Array(phi(gpu([t, x, y]), res.u))[1] for x in xs for y in ys],
                            length(xs), length(ys))
        u_error = abs.(u_predict .- u_real)
        title = @sprintf(&quot;predict, t = %.3f&quot;, t)
        p1 = plot(xs, ys, u_predict, st = :surface, label = &quot;&quot;, title = title)
        title = @sprintf(&quot;real&quot;)
        p2 = plot(xs, ys, u_real, st = :surface, label = &quot;&quot;, title = title)
        title = @sprintf(&quot;error&quot;)
        p3 = plot(xs, ys, u_error, st = :contourf, label = &quot;&quot;, title = title)
        plot(p1, p2, p3)
    end
    gif(anim, &quot;3pde.gif&quot;, fps = 10)
end

plot_(res)</code></pre><p><img src="https://user-images.githubusercontent.com/12683885/129949743-9471d230-c14f-4105-945f-6bc52677d40e.gif" alt="3pde"/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../brusselator/">Â« Automated Efficient Solution of Nonlinear Partial Differential Equations</a><a class="docs-footer-nextpage" href="../massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs Â»</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Tuesday 24 January 2023 02:18">Tuesday 24 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
