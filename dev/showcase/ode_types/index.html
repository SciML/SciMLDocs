<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System · Overview of Julia&#39;s SciML</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://docs.sciml.ai/stable/showcase/ode_types/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/installation/">Installing SciML Software</a></li><li><a class="tocitem" href="../../getting_started/first_simulation/">Build and run your first simulation with Julia&#39;s SciML</a></li><li><a class="tocitem" href="../../getting_started/first_optimization/">Solve your first optimization problem</a></li><li><a class="tocitem" href="../../getting_started/fit_simulation/">Fit a simulation to a dataset</a></li><li><a class="tocitem" href="../../getting_started/find_root/">Find the root of an equation (i.e. solve f(x)=0)</a></li><li><a class="tocitem" href="../../getting_started/integral_approx/">Numerically approximate an integral</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../comparisons/python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../../comparisons/matlab/">Getting Started with  Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../../comparisons/r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li><a class="tocitem" href="../../comparisons/cppfortran/">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../missing_physics/">Auto-complete mechanistic models by embedding machine learning into differential equations</a></li><li><a class="tocitem" href="../bayesian_neural_ode/">Bayesian automated model discovery with quantified uncertainties and probability estimates</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li><a class="tocitem" href="../pinngpu/">GPU-Accelerated Physics-Informed Neural Network PDE Solvers</a></li><li><a class="tocitem" href="../massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox" checked/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li class="is-active"><a class="tocitem" href>Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Unit-Checked-Arithmetic-via-Unitful.jl"><span>Unit Checked Arithmetic via Unitful.jl</span></a></li><li><a class="tocitem" href="#Using-Unitful"><span>Using Unitful</span></a></li><li class="toplevel"><a class="tocitem" href="#Using-Unitful-with-DifferentialEquations.jl"><span>Using Unitful with DifferentialEquations.jl</span></a></li><li class="toplevel"><a class="tocitem" href="#Numbers-with-Uncertainties"><span>Numbers with Uncertainties</span></a></li><li><a class="tocitem" href="#Caveat-about-Measurement-type"><span>Caveat about <code>Measurement</code> type</span></a></li><li><a class="tocitem" href="#Radioactive-Decay-of-Carbon-14"><span>Radioactive Decay of Carbon-14</span></a></li><li><a class="tocitem" href="#Simple-pendulum"><span>Simple pendulum</span></a></li><li><a class="tocitem" href="#Arbitrary-amplitude"><span>Arbitrary amplitude</span></a></li></ul></li><li><a class="tocitem" href="../symbolic_analysis/">Symbolic Analysis of Parameter Identifiability and Model Stability</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/equation_solvers/">Equation Solvers</a></li><li><a class="tocitem" href="../../highlevels/inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li><li><a class="tocitem" href="../../highlevels/partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../../highlevels/model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../../highlevels/symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../../highlevels/array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../../highlevels/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../highlevels/plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../../highlevels/implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../../highlevels/symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../../highlevels/interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../../highlevels/developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Showcase of Cool Examples</a></li><li><a class="is-disabled">Useful Cool Wonky Things</a></li><li class="is-active"><a href>Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/showcase/ode_types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ode_types"><a class="docs-heading-anchor" href="#ode_types">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a><a id="ode_types-1"></a><a class="docs-heading-anchor-permalink" href="#ode_types" title="Permalink"></a></h1><p>One of the nice things about DifferentialEquations.jl is that it is designed with Julia&#39;s type system in mind. What this means is, if you have properly defined a Number type, you can use this number type in DifferentialEquations.jl&#39;s algorithms! [Note that this is restricted to the native algorithms of OrdinaryDiffEq.jl. The other solvers such as ODE.jl, Sundials.jl, and ODEInterface.jl are not compatible with some number systems.]</p><p>DifferentialEquations.jl determines the numbers to use in its solvers via the types that are designated by <code>tspan</code> and the initial condition of the problem. It will keep the time values in the same type as tspan, and the solution values in the same type as the initial condition. [Note that adaptive timestepping requires that the time type is compaible with <code>sqrt</code> and <code>^</code> functions. Thus dt cannot be Integer or numbers like that if adaptive timestepping is chosen].</p><p>Let&#39;s solve the linear ODE first define an easy way to get ODEProblems for the linear ODE:</p><pre><code class="language-julia hljs">using DifferentialEquations
f = (u,p,t) -&gt; (p*u)
prob_ode_linear = ODEProblem(f,1/2,(0.0,1.0),1.01);</code></pre><p>First let&#39;s solve it using Float64s. To do so, we just need to set u0 to a Float64 (which is done by the default) and dt should be a float as well.</p><pre><code class="language-julia hljs">prob = prob_ode_linear
sol =solve(prob,Tsit5())
println(sol)</code></pre><p>Notice that both the times and the solutions were saved as Float64. Let&#39;s change the time to use rational values. Rationals are not compatible with adaptive time stepping since they do not have an L2 norm (this can be worked around by defining <code>internalnorm</code>, but rationals already explode in size!). To account for this, let&#39;s turn off adaptivity as well:</p><pre><code class="language-julia hljs">prob = ODEProblem(f,1/2,(0//1,1//1),101//100);
sol = solve(prob,RK4(),dt=1//2^(6),adaptive=false)
println(sol)</code></pre><p>Now let&#39;s do something fun. Let&#39;s change the solution to use <code>Rational{BigInt}</code> and print out the value at the end of the simulation. To do so, simply change the definition of the initial condition.</p><pre><code class="language-julia hljs">prob = ODEProblem(f,BigInt(1)//BigInt(2),(0//1,1//1),101//100);
sol =solve(prob,RK4(),dt=1//2^(6),adaptive=false)
println(sol[end])</code></pre><p>That&#39;s one huge fraction!</p><h1 id="Unit-Checked-Arithmetic-via-Unitful.jl"><a class="docs-heading-anchor" href="#Unit-Checked-Arithmetic-via-Unitful.jl">Unit Checked Arithmetic via Unitful.jl</a><a id="Unit-Checked-Arithmetic-via-Unitful.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Checked-Arithmetic-via-Unitful.jl" title="Permalink"></a></h1><p>Units and dimensional analysis are standard tools across the sciences for checking the correctness of your equation. However, most ODE solvers only allow for the equation to be in dimensionless form, leaving it up to the user to both convert the equation to a dimensionless form, punch in the equations, and hopefully not make an error along the way.</p><p>DifferentialEquations.jl allows for one to use Unitful.jl to have unit-checked arithmetic natively in the solvers. Given the dispatch implementation of the Unitful, this has little overhead.</p><h2 id="Using-Unitful"><a class="docs-heading-anchor" href="#Using-Unitful">Using Unitful</a><a id="Using-Unitful-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Unitful" title="Permalink"></a></h2><p>To use Unitful, you need to have the package installed. Then you can add units to your variables. For example:</p><pre><code class="language-julia hljs">using Unitful
t = 1.0u&quot;s&quot;</code></pre><p>Notice that <code>t</code> is a variable with units in seconds. If we make another value with seconds, they can add</p><pre><code class="language-julia hljs">t2 = 1.02u&quot;s&quot;
t+t2</code></pre><p>and they can multiply:</p><pre><code class="language-julia hljs">t*t2</code></pre><p>You can even do rational roots:</p><pre><code class="language-julia hljs">sqrt(t)</code></pre><p>Many operations work. These operations will check to make sure units are correct, and will throw an error for incorrect operations:</p><pre><code class="language-julia hljs">t + sqrt(t)</code></pre><h1 id="Using-Unitful-with-DifferentialEquations.jl"><a class="docs-heading-anchor" href="#Using-Unitful-with-DifferentialEquations.jl">Using Unitful with DifferentialEquations.jl</a><a id="Using-Unitful-with-DifferentialEquations.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Using-Unitful-with-DifferentialEquations.jl" title="Permalink"></a></h1><p>Just like with other number systems, you can choose the units for your numbers by simply specifying the units of the initial condition and the timestep. For example, to solve the linear ODE where the variable has units of Newton&#39;s and <code>t</code> is in Seconds, we would use:</p><pre><code class="language-julia hljs">using DifferentialEquations
f = (y,p,t) -&gt; 0.5*y
u0 = 1.5u&quot;N&quot;
prob = ODEProblem(f,u0,(0.0u&quot;s&quot;,1.0u&quot;s&quot;))
sol = solve(prob,Tsit5())</code></pre><p>Notice that we recieved a unit mismatch error. This is correctly so! Remember that for an ODE:</p><p class="math-container">\[\frac{dy}{dt} = f(t,y)\]</p><p>we must have that <code>f</code> is a rate, i.e. <code>f</code> is a change in <code>y</code> per unit time. So we need to fix the units of <code>f</code> in our example to be <code>N/s</code>. Notice that we then do not receive an error if we do the following:</p><pre><code class="language-julia hljs">f = (y,p,t) -&gt; 0.5*y/3.0u&quot;s&quot;
prob = ODEProblem(f,u0,(0.0u&quot;s&quot;,1.0u&quot;s&quot;))
sol = solve(prob,Tsit5())</code></pre><p>This gives a a normal solution object. Notice that the values are all with the correct units:</p><pre><code class="language-julia hljs">print(sol[:])</code></pre><p>We can plot the solution by removing the units:</p><pre><code class="language-julia hljs">using Plots
gr()
plot(ustrip(sol.t),ustrip(sol[:]),lw=3)</code></pre><h1 id="Numbers-with-Uncertainties"><a class="docs-heading-anchor" href="#Numbers-with-Uncertainties">Numbers with Uncertainties</a><a id="Numbers-with-Uncertainties-1"></a><a class="docs-heading-anchor-permalink" href="#Numbers-with-Uncertainties" title="Permalink"></a></h1><p>The result of a measurement should be given as a number with an attached uncertainties, besides the physical unit, and all operations performed involving the result of the measurement should propagate the uncertainty, taking care of correlation between quantities.</p><p>There is a Julia package for dealing with numbers with uncertainties: <a href="https://github.com/JuliaPhysics/Measurements.jl"><code>Measurements.jl</code></a>.  Thanks to Julia&#39;s features, <code>DifferentialEquations.jl</code> easily works together with <code>Measurements.jl</code> out-of-the-box.</p><p>This notebook will cover some of the examples from the tutorial about classical Physics.</p><h2 id="Caveat-about-Measurement-type"><a class="docs-heading-anchor" href="#Caveat-about-Measurement-type">Caveat about <code>Measurement</code> type</a><a id="Caveat-about-Measurement-type-1"></a><a class="docs-heading-anchor-permalink" href="#Caveat-about-Measurement-type" title="Permalink"></a></h2><p>Before going on with the tutorial, we must point up a subtlety of <code>Measurements.jl</code> that you should be aware of:</p><pre><code class="language-julia hljs">using Measurements

5.23 ± 0.14 === 5.23 ± 0.14</code></pre><pre><code class="language-julia hljs">(5.23± 0.14) - (5.23 ± 0.14)</code></pre><pre><code class="language-julia hljs">(5.23 ± 0.14) / (5.23 ± 0.14)</code></pre><p>The two numbers above, even though have the same nominal value and the same uncertainties, are actually two different measurements that only by chance share the same figures and their difference and their ratio have a non-zero uncertainty.  It is common in physics to get very similar, or even equal, results for a repeated measurement, but the two measurements are not the same thing.</p><p>Instead, if you have <em>one measurement</em> and want to perform some operations involving it, you have to assign it to a variable:</p><pre><code class="language-julia hljs">x = 5.23 ± 0.14
x === x</code></pre><pre><code class="language-julia hljs">x - x</code></pre><pre><code class="language-julia hljs">x / x</code></pre><h2 id="Radioactive-Decay-of-Carbon-14"><a class="docs-heading-anchor" href="#Radioactive-Decay-of-Carbon-14">Radioactive Decay of Carbon-14</a><a id="Radioactive-Decay-of-Carbon-14-1"></a><a class="docs-heading-anchor-permalink" href="#Radioactive-Decay-of-Carbon-14" title="Permalink"></a></h2><p>The rate of decay of carbon-14 is governed by a first order linear ordinary differential equation</p><p class="math-container">\[\frac{\mathrm{d}u(t)}{\mathrm{d}t} = -\frac{u(t)}{\tau}\]</p><p>where <span>$\tau$</span> is the mean lifetime of carbon-14, which is related to the half-life <span>$t_{1/2} = (5730 \pm 40)$</span> years by the relation <span>$\tau = t_{1/2}/\ln(2)$</span>.</p><pre><code class="language-julia hljs">using DifferentialEquations, Measurements, Plots

# Half-life and mean lifetime of radiocarbon, in years
t_12 = 5730 ± 40
τ = t_12 / log(2)

#Setup
u₀ = 1 ± 0
tspan = (0.0, 10000.0)

#Define the problem
radioactivedecay(u,p,t) = - u / τ

#Pass to solver
prob = ODEProblem(radioactivedecay, u₀, tspan)
sol = solve(prob, Tsit5(), reltol = 1e-8)

# Analytic solution
u = exp.(- sol.t / τ)

plot(sol.t, sol.u, label = &quot;Numerical&quot;, xlabel = &quot;Years&quot;, ylabel = &quot;Fraction of Carbon-14&quot;)
plot!(sol.t, u, label = &quot;Analytic&quot;)</code></pre><p>The two curves are perfectly superimposed, indicating that the numerical solution matches the analytic one.  We can check that also the uncertainties are correctly propagated in the numerical solution:</p><pre><code class="language-julia hljs">println(&quot;Quantity of carbon-14 after &quot;,  sol.t[11], &quot; years:&quot;)
println(&quot;Numerical: &quot;, sol[11])
println(&quot;Analytic:  &quot;, u[11])</code></pre><p>Both the value of the numerical solution and its uncertainty match the analytic solution within the requested tolerance.  We can also note that close to 5730 years after the beginning of the decay (half-life of the radioisotope), the fraction of carbon-14 that survived is about 0.5.</p><h2 id="Simple-pendulum"><a class="docs-heading-anchor" href="#Simple-pendulum">Simple pendulum</a><a id="Simple-pendulum-1"></a><a class="docs-heading-anchor-permalink" href="#Simple-pendulum" title="Permalink"></a></h2><h3 id="Small-angles-approximation"><a class="docs-heading-anchor" href="#Small-angles-approximation">Small angles approximation</a><a id="Small-angles-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Small-angles-approximation" title="Permalink"></a></h3><p>The next problem we are going to study is the simple pendulum in the approximation of small angles.  We address this simplified case because there exists an easy analytic solution to compare.</p><p>The differential equation we want to solve is</p><p class="math-container">\[\ddot{\theta} + \frac{g}{L} \theta = 0\]</p><p>where <span>$g = (9.79 \pm 0.02)~\mathrm{m}/\mathrm{s}^2$</span> is the gravitational acceleration measured where the experiment is carried out, and <span>$L = (1.00 \pm 0.01)~\mathrm{m}$</span> is the length of the pendulum.</p><p>When you set up the problem for <code>DifferentialEquations.jl</code> remember to define the measurements as variables, as seen above.</p><pre><code class="language-julia hljs">using DifferentialEquations, Measurements, Plots

g = 9.79 ± 0.02; # Gravitational constants
L = 1.00 ± 0.01; # Length of the pendulum

#Initial Conditions
u₀ = [0 ± 0, π / 60 ± 0.01] # Initial speed and initial angle
tspan = (0.0, 6.3)

#Define the problem
function simplependulum(du,u,p,t)
    θ  = u[1]
    dθ = u[2]
    du[1] = dθ
    du[2] = -(g/L)*θ
end

#Pass to solvers
prob = ODEProblem(simplependulum, u₀, tspan)
sol = solve(prob, Tsit5(), reltol = 1e-6)

# Analytic solution
u = u₀[2] .* cos.(sqrt(g / L) .* sol.t)

plot(sol.t, getindex.(sol.u, 2), label = &quot;Numerical&quot;)
plot!(sol.t, u, label = &quot;Analytic&quot;)</code></pre><p>Also in this case there is a perfect superimposition between the two curves, including their uncertainties.</p><p>We can also have a look at the difference between the two solutions:</p><pre><code class="language-julia hljs">plot(sol.t, getindex.(sol.u, 2) .- u, label = &quot;&quot;)</code></pre><h2 id="Arbitrary-amplitude"><a class="docs-heading-anchor" href="#Arbitrary-amplitude">Arbitrary amplitude</a><a id="Arbitrary-amplitude-1"></a><a class="docs-heading-anchor-permalink" href="#Arbitrary-amplitude" title="Permalink"></a></h2><p>Now that we know how to solve differential equations involving numbers with uncertainties we can solve the simple pendulum problem without any approximation.  This time the differential equation to solve is the following:</p><p class="math-container">\[\ddot{\theta} + \frac{g}{L} \sin(\theta) = 0\]</p><pre><code class="language-julia hljs">g = 9.79 ± 0.02; # Gravitational constants
L = 1.00 ± 0.01; # Length of the pendulum

#Initial Conditions
u₀ = [0 ± 0, π / 3 ± 0.02] # Initial speed and initial angle
tspan = (0.0, 6.3)

#Define the problem
function simplependulum(du,u,p,t)
    θ  = u[1]
    dθ = u[2]
    du[1] = dθ
    du[2] = -(g/L) * sin(θ)
end

#Pass to solvers
prob = ODEProblem(simplependulum, u₀, tspan)
sol = solve(prob, Tsit5(), reltol = 1e-6)

plot(sol.t, getindex.(sol.u, 2), label = &quot;Numerical&quot;)</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../massively_parallel_gpu/">« Massively Data-Parallel ODE Solving on GPUs</a><a class="docs-footer-nextpage" href="../symbolic_analysis/">Symbolic Analysis of Parameter Identifiability and Model Stability »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Tuesday 6 December 2022 02:04">Tuesday 6 December 2022</span>. Using Julia version 1.8.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
