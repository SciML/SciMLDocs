<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability · Overview of Julia&#39;s SciML</title><meta name="title" content="Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability · Overview of Julia&#39;s SciML"/><meta property="og:title" content="Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability · Overview of Julia&#39;s SciML"/><meta property="twitter:title" content="Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability · Overview of Julia&#39;s SciML"/><meta name="description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="twitter:description" content="Documentation for Overview of Julia&#39;s SciML."/><meta property="og:url" content="https://docs.sciml.ai/stable/showcase/symbolic_analysis/"/><meta property="twitter:url" content="https://docs.sciml.ai/stable/showcase/symbolic_analysis/"/><link rel="canonical" href="https://docs.sciml.ai/stable/showcase/symbolic_analysis/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Overview of Julia&#39;s SciML logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Overview of Julia&#39;s SciML</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">SciML: Open Source Software for Scientific Machine Learning with Julia</a></li><li><span class="tocitem">Getting Started</span><ul><li><a class="tocitem" href="../../getting_started/getting_started/">Getting Started with Julia&#39;s SciML</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">New User Tutorials</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../getting_started/installation/">Installing SciML Software</a></li><li><a class="tocitem" href="../../getting_started/first_simulation/">Build and run your first simulation with Julia&#39;s SciML</a></li><li><a class="tocitem" href="../../getting_started/first_optimization/">Solve your first optimization problem</a></li><li><a class="tocitem" href="../../getting_started/fit_simulation/">Fit a simulation to a dataset</a></li><li><a class="tocitem" href="../../getting_started/find_root/">Find the root of an equation (i.e. solve f(u)=0)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Comparison With Other Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../comparisons/python/">Getting Started with Julia&#39;s SciML for the Python User</a></li><li><a class="tocitem" href="../../comparisons/matlab/">Getting Started with Julia&#39;s SciML for the MATLAB User</a></li><li><a class="tocitem" href="../../comparisons/r/">Getting Started with Julia&#39;s SciML for the R User</a></li><li><a class="tocitem" href="../../comparisons/cppfortran/">Getting Started with Julia&#39;s SciML for the C++/Fortran User</a></li></ul></li></ul></li><li><span class="tocitem">Showcase of Cool Examples</span><ul><li><a class="tocitem" href="../showcase/">The SciML Showcase</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Automated Model Discovery</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../missing_physics/">Automatically Discover Missing Physics by Embedding Machine Learning into Differential Equations</a></li><li><a class="tocitem" href="../bayesian_neural_ode/">Uncertainty Quantified Deep Bayesian Model Discovery</a></li><li><a class="tocitem" href="../optimal_data_gathering_for_missing_physics/">Optimal Data Gathering for Missing Physics</a></li><li><a class="tocitem" href="../blackhole/">Discovering the Relativistic Corrections to Binary Black Hole Dynamics</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Solving Difficult Equations Efficiently</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../brusselator/">Automated Efficient Solution of Nonlinear Partial Differential Equations</a></li><li><a class="tocitem" href="../pinngpu/">GPU-Accelerated Physics-Informed Neural Network (PINN) PDE Solvers</a></li><li><a class="tocitem" href="../massively_parallel_gpu/">Massively Data-Parallel ODE Solving on GPUs</a></li><li><a class="tocitem" href="../gpu_spde/">GPU-Accelerated Stochastic Partial Differential Equations</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox" checked/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Useful Cool Wonky Things</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../ode_types/">Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a></li><li class="is-active"><a class="tocitem" href>Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a><ul class="internal"><li class="toplevel"><a class="tocitem" href="#Automated-Index-Reduction-of-DAEs"><span>Automated Index Reduction of DAEs</span></a></li><li><a class="tocitem" href="#Copy-Pastable-Example"><span>Copy-Pastable Example</span></a></li><li><a class="tocitem" href="#Explanation"><span>Explanation</span></a></li><li class="toplevel"><a class="tocitem" href="#Parameter-Identifiability-in-ODE-Models"><span>Parameter Identifiability in ODE Models</span></a></li><li><a class="tocitem" href="#Local-Identifiability"><span>Local Identifiability</span></a></li><li><a class="tocitem" href="#Global-Identifiability"><span>Global Identifiability</span></a></li></ul></li><li><a class="tocitem" href="../optimization_under_uncertainty/">Optimization Under Uncertainty</a></li></ul></li></ul></li><li><span class="tocitem">What is SciML?</span><ul><li><a class="tocitem" href="../../overview/">Detailed Overview of the SciML Software Ecosystem</a></li><li><input class="collapse-toggle" id="menuitem-4-2" type="checkbox"/><label class="tocitem" for="menuitem-4-2"><span class="docs-label">Solvers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/equation_solvers/">Equation Solvers</a></li><li><a class="tocitem" href="../../highlevels/inverse_problems/">Parameter Estimation, Bayesian Analysis, and Inverse Problems</a></li><li><a class="tocitem" href="../../highlevels/partial_differential_equation_solvers/">Partial Differential Equations (PDE)</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-3" type="checkbox"/><label class="tocitem" for="menuitem-4-3"><span class="docs-label">Modeling Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/modeling_languages/">Modeling Languages</a></li><li><a class="tocitem" href="../../highlevels/model_libraries_and_importers/">Model Libraries and Importers</a></li><li><a class="tocitem" href="../../highlevels/symbolic_tools/">Symbolic Model Tooling and JuliaSymbolics</a></li><li><a class="tocitem" href="../../highlevels/array_libraries/">Modeling Array Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-4" type="checkbox"/><label class="tocitem" for="menuitem-4-4"><span class="docs-label">Simulation Analysis</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/parameter_analysis/">Parameter Analysis Utilities</a></li><li><a class="tocitem" href="../../highlevels/uncertainty_quantification/">Uncertainty Quantification</a></li><li><a class="tocitem" href="../../highlevels/plots_visualization/">SciML-Supported Plotting and Visualization Libraries</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-5" type="checkbox"/><label class="tocitem" for="menuitem-4-5"><span class="docs-label">Machine Learning</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/function_approximation/">Function Approximation</a></li><li><a class="tocitem" href="../../highlevels/implicit_layers/">Implicit Layer Deep Learning</a></li><li><a class="tocitem" href="../../highlevels/symbolic_learning/">Symbolic Learning and Artificial Intelligence</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-6" type="checkbox"/><label class="tocitem" for="menuitem-4-6"><span class="docs-label">Developer Tools</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/numerical_utilities/">SciML Numerical Utility Libraries</a></li><li><a class="tocitem" href="../../highlevels/interfaces/">The SciML Interface Libraries</a></li><li><a class="tocitem" href="../../highlevels/developer_documentation/">Developer Documentation</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-4-7" type="checkbox"/><label class="tocitem" for="menuitem-4-7"><span class="docs-label">Extra Learning Resources</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../highlevels/learning_resources/">Curated Learning, Teaching, and Training Resources</a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Showcase of Cool Examples</a></li><li><a class="is-disabled">Useful Cool Wonky Things</a></li><li class="is-active"><a href>Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/SciMLDocs/blob/main/docs/src/showcase/symbolic_analysis.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="symbolic_analysis"><a class="docs-heading-anchor" href="#symbolic_analysis">Symbolic-Numeric Analysis of Parameter Identifiability and Model Stability</a><a id="symbolic_analysis-1"></a><a class="docs-heading-anchor-permalink" href="#symbolic_analysis" title="Permalink"></a></h1><p>The mixture of symbolic computing with numeric computing, which we call symbolic-numeric programming, is one of the central features of the SciML ecosystem. With core aspects like the <a href="https://symbolics.juliasymbolics.org/stable/">Symbolics.jl Computer Algebra System</a> and its integration via <a href="https://docs.sciml.ai/ModelingToolkit/stable/">ModelingToolkit.jl</a>, the SciML ecosystem gracefully mixes analytical symbolic computations with the numerical solver processes to accelerate solvers, give additional information (sparsity, identifiability), automatically fix numerical stability issues, and more.</p><p>In this showcase, we will highlight two aspects of symbolic-numeric programming.</p><ol><li>Automated index reduction of DAEs. While arbitrary <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/dae_example/">differential-algebraic equation systems can be written in DifferentialEquations.jl</a>, not all mathematical formulations of a system are equivalent. Some are numerically difficult to solve, or even require special solvers. Some are easy. Can we recognize which formulations are hard and automatically transform them into the easy ones? Yes.</li><li>Structural parameter identifiability. When fitting parameters to data, there&#39;s always assumptions about whether there is a unique parameter set that achieves such a data fit. But is this actually the case? The structural identifiability tooling allows one to analytically determine whether, in the limit of infinite data on a subset of observables, one could in theory uniquely identify the parameters (global identifiability), identify the parameters up to a discrete set (local identifiability), or whether there&#39;s an infinite manifold of solutions to the inverse problem (nonidentifiable).</li></ol><p>Let&#39;s dig into these two cases!</p><h1 id="Automated-Index-Reduction-of-DAEs"><a class="docs-heading-anchor" href="#Automated-Index-Reduction-of-DAEs">Automated Index Reduction of DAEs</a><a id="Automated-Index-Reduction-of-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Automated-Index-Reduction-of-DAEs" title="Permalink"></a></h1><p>In many cases one may accidentally write down a DAE that is not easily solvable by numerical methods. In this tutorial, we will walk through an example of a pendulum which accidentally generates an index-3 DAE, and show how to use the <code>modelingtoolkitize</code> to correct the model definition before solving.</p><h2 id="Copy-Pastable-Example"><a class="docs-heading-anchor" href="#Copy-Pastable-Example">Copy-Pastable Example</a><a id="Copy-Pastable-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Copy-Pastable-Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">import ModelingToolkit as MTK
import LinearAlgebra
import OrdinaryDiffEq as ODE
import Plots

function pendulum!(du, u, p, t)
    x, dx, y, dy, T = u
    g, L = p
    du[1] = dx
    du[2] = T * x
    du[3] = dy
    du[4] = T * y - g
    du[5] = x^2 + y^2 - L^2
    return nothing
end
pendulum_fun! = ODE.ODEFunction(pendulum!, mass_matrix = LinearAlgebra.Diagonal([1, 1, 1, 1, 0]))
u0 = [1.0, 0, 0, 0, 0]
p = [9.8, 1]
tspan = (0, 10.0)
pendulum_prob = ODE.ODEProblem(pendulum_fun!, u0, tspan, p)
traced_sys = MTK.modelingtoolkitize(pendulum_prob)
pendulum_sys = MTK.structural_simplify(MTK.dae_index_lowering(traced_sys))
prob = ODE.ODEProblem(pendulum_sys, [], tspan)
sol = ODE.solve(prob, ODE.Rodas5P(), abstol = 1e-8, reltol = 1e-8)
Plots.plot(sol, vars = MTK.unknowns(traced_sys))</code></pre><img src="3ec187de.svg" alt="Example block output"/><h2 id="Explanation"><a class="docs-heading-anchor" href="#Explanation">Explanation</a><a id="Explanation-1"></a><a class="docs-heading-anchor-permalink" href="#Explanation" title="Permalink"></a></h2><h3 id="Attempting-to-Solve-the-Equation"><a class="docs-heading-anchor" href="#Attempting-to-Solve-the-Equation">Attempting to Solve the Equation</a><a id="Attempting-to-Solve-the-Equation-1"></a><a class="docs-heading-anchor-permalink" href="#Attempting-to-Solve-the-Equation" title="Permalink"></a></h3><p>In this tutorial, we will look at the pendulum system:</p><p class="math-container">\[\begin{aligned}
    x^\prime &amp;= v_x\\
    v_x^\prime &amp;= Tx\\
    y^\prime &amp;= v_y\\
    v_y^\prime &amp;= Ty - g\\
    0 &amp;= x^2 + y^2 - L^2
\end{aligned}\]</p><p>As a good DifferentialEquations.jl user, one would follow <a href="https://docs.sciml.ai/DiffEqDocs/stable/tutorials/dae_example/#Mass-Matrix-Differential-Algebraic-Equations-(DAEs)">the mass matrix DAE tutorial</a> to arrive at code for simulating the model:</p><pre><code class="language-julia hljs">import OrdinaryDiffEq as ODE
import LinearAlgebra
function pendulum!(du, u, p, t)
    x, dx, y, dy, T = u
    g, L = p
    du[1] = dx
    du[2] = T * x
    du[3] = dy
    du[4] = T * y - g
    du[5] = x^2 + y^2 - L^2
end
pendulum_fun! = ODE.ODEFunction(pendulum!, mass_matrix = LinearAlgebra.Diagonal([1, 1, 1, 1, 0]))
u0 = [1.0, 0, 0, 0, 0];
p = [9.8, 1];
tspan = (0, 10.0);
pendulum_prob = ODE.ODEProblem(pendulum_fun!, u0, tspan, p)
ODE.solve(pendulum_prob, ODE.Rodas5P())</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">retcode: Unstable
Interpolation: specialized 4rd order &quot;free&quot; stiffness-aware interpolation
t: 5-element Vector{Float64}:
 0.0
 1.0e-6
 1.1e-5
 2.9844380280222975e-5
 3.916953199555279e-5
u: 5-element Vector{Vector{Float64}}:
 [1.0, 0.0, 0.0, 0.0, 0.0]
 [1.0, 0.0, -4.900000000000009e-12, -9.800000000000072e-6, 0.0]
 [1.0, -5.282200000000052e-16, -5.929000000000031e-10, -0.00010780000000000034, 1.2105282010215346e-11]
 [1.0, -1.7340838406781296e-13, -4.364366468121788e-9, -0.000292474926746187, 3.6305781792415833e-8]
 [1.0, -1.6753118817314227e-12, -7.517835960078196e-9, -0.0003838614135564203, 1.4383072941635003e-6]</code></pre><p>However, one will quickly be greeted with the unfortunate message:</p><pre><code class="nohighlight hljs">┌ Warning: First function call produced NaNs. Exiting.
└ @ OrdinaryDiffEq C:\Users\accou\.julia\packages\OrdinaryDiffEq\yCczp\src\initdt.jl:76
┌ Warning: Automatic dt set the starting dt as NaN, causing instability.
└ @ OrdinaryDiffEq C:\Users\accou\.julia\packages\OrdinaryDiffEq\yCczp\src\solve.jl:485
┌ Warning: NaN dt detected. Likely a NaN value in the state, parameters, or derivative value caused this outcome.
└ @ SciMLBase C:\Users\accou\.julia\packages\SciMLBase\DrPil\src\integrator_interface.jl:325</code></pre><p>Did you implement the DAE incorrectly? No. Is the solver broken? No.</p><h3 id="Understanding-DAE-Index"><a class="docs-heading-anchor" href="#Understanding-DAE-Index">Understanding DAE Index</a><a id="Understanding-DAE-Index-1"></a><a class="docs-heading-anchor-permalink" href="#Understanding-DAE-Index" title="Permalink"></a></h3><p>It turns out that this is a property of the DAE that we are attempting to solve. This kind of DAE is known as an index-3 DAE. For a complete discussion of DAE index, see <a href="http://www.scholarpedia.org/article/Differential-algebraic_equations">this article</a>. Essentially, the issue here is that we have 4 differential variables (<span>$x$</span>, <span>$v_x$</span>, <span>$y$</span>, <span>$v_y$</span>) and one algebraic variable <span>$T$</span> (which we can know because there is no <code>D(T)</code> term in the equations). An index-1 DAE always satisfies that the Jacobian of the algebraic equations is non-singular. Here, the first 4 equations are differential equations, with the last term the algebraic relationship. However, the partial derivative of <code>x^2 + y^2 - L^2</code> w.r.t. <code>T</code> is zero, and thus the Jacobian of the algebraic equations is the zero matrix, and thus it&#39;s singular. This is a quick way to see whether the DAE is index 1!</p><p>The problem with higher order DAEs is that the matrices used in Newton solves are singular or close to singular when applied to such problems. Because of this fact, the nonlinear solvers (or Rosenbrock methods) break down, making them difficult to solve. The classic paper <a href="https://epubs.siam.org/doi/10.1137/0903023">DAEs are not ODEs</a> goes into detail on this and shows that many methods are no longer convergent when index is higher than one. So, it&#39;s not necessarily the fault of the solver or the implementation: this is known.</p><p>But that&#39;s not a satisfying answer, so what do you do about it?</p><h3 id="Transforming-Higher-Order-DAEs-to-Index-1-DAEs"><a class="docs-heading-anchor" href="#Transforming-Higher-Order-DAEs-to-Index-1-DAEs">Transforming Higher Order DAEs to Index-1 DAEs</a><a id="Transforming-Higher-Order-DAEs-to-Index-1-DAEs-1"></a><a class="docs-heading-anchor-permalink" href="#Transforming-Higher-Order-DAEs-to-Index-1-DAEs" title="Permalink"></a></h3><p>It turns out that higher order DAEs can be transformed into lower order DAEs. <a href="https://github.com/SciML/ModelingToolkit.jl/files/12829393/DAE_slides.pdf">If you differentiate the last equation two times and perform a substitution, you can arrive at the following set of equations</a>:</p><p class="math-container">\[\begin{aligned}
x^\prime =&amp; v_x \\
v_x^\prime =&amp; x T \\
y^\prime =&amp; v_y \\
v_y^\prime =&amp; y T - g \\
0 =&amp; 2 \left(v_x^{2} + v_y^{2} + y ( y T - g ) + T x^2 \right)
\end{aligned}\]</p><p>Note that this is mathematically equivalent to the equation that we had before, but the Jacobian w.r.t. <code>T</code> of the algebraic equation is no longer zero because of the substitution. This means that if you wrote down this version of the model, it will be index-1 and solve correctly! In fact, this is how DAE index is commonly defined: the number of differentiations it takes to transform the DAE into an ODE, where an ODE is an index-0 DAE by substituting out all of the algebraic relationships.</p><h3 id="Automating-the-Index-Reduction"><a class="docs-heading-anchor" href="#Automating-the-Index-Reduction">Automating the Index Reduction</a><a id="Automating-the-Index-Reduction-1"></a><a class="docs-heading-anchor-permalink" href="#Automating-the-Index-Reduction" title="Permalink"></a></h3><p>However, requiring the user to sit there and work through this process on potentially millions of equations is an unfathomable mental overhead. But, we can avoid this by using methods like <a href="https://ptolemy.berkeley.edu/projects/embedded/eecsx44/lectures/Spring2013/modelica-dae-part-2.pdf">the Pantelides algorithm</a> for automatically performing this reduction to index 1. While this requires the ModelingToolkit symbolic form, we use <code>modelingtoolkitize</code> to transform the numerical code into symbolic code, run <code>structural_simplify</code> to simplify the system and lower the index, then transform back to numerical code with <code>ODEProblem</code>, and solve with a numerical solver. Let&#39;s try that out:</p><pre><code class="language-julia hljs">traced_sys = MTK.modelingtoolkitize(pendulum_prob)
pendulum_sys = MTK.structural_simplify(traced_sys)
prob = ODE.ODEProblem(pendulum_sys, Pair[], tspan)
sol = ODE.solve(prob, ODE.Rodas5P())

Plots.plot(sol, vars = MTK.unknowns(traced_sys))</code></pre><img src="2f1f18db.svg" alt="Example block output"/><p>Note that plotting using <code>unknowns(traced_sys)</code> is done so that any variables which are symbolically eliminated, or any variable reordering done for enhanced parallelism/performance, still show up in the resulting plot and the plot is shown in the same order as the original numerical code.</p><p>Note that we can even go a bit further. If we use the <code>ODEProblem</code> constructor, we represent the mass matrix DAE of the index-reduced system, which can be solved via:</p><pre><code class="language-julia hljs">traced_sys = MTK.modelingtoolkitize(pendulum_prob)
pendulum_sys = MTK.structural_simplify(MTK.dae_index_lowering(traced_sys))
prob = ODE.ODEProblem(pendulum_sys, Pair[], tspan)
sol = ODE.solve(prob, ODE.Rodas5P(), abstol = 1e-8, reltol = 1e-8)
Plots.plot(sol, vars = MTK.unknowns(traced_sys))</code></pre><img src="27ac6c6a.svg" alt="Example block output"/><p>And there you go: this has transformed the model from being too hard to solve with implicit DAE solvers, to something that is easily solved.</p><h1 id="Parameter-Identifiability-in-ODE-Models"><a class="docs-heading-anchor" href="#Parameter-Identifiability-in-ODE-Models">Parameter Identifiability in ODE Models</a><a id="Parameter-Identifiability-in-ODE-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Parameter-Identifiability-in-ODE-Models" title="Permalink"></a></h1><p>Ordinary differential equations are commonly used for modeling real-world processes. The problem of parameter identifiability is one of the key design challenges for mathematical models. A parameter is said to be <em>identifiable</em> if one can recover its value from experimental data. <em>Structural</em> identifiability is a theoretical property of a model that answers this question. In this tutorial, we will show how to use <code>StructuralIdentifiability.jl</code> with <code>ModelingToolkit.jl</code> to assess identifiability of parameters in ODE models. The theory behind <code>StructuralIdentifiability.jl</code> is presented in paper <sup class="footnote-reference"><a id="citeref-4" href="#footnote-4">[4]</a></sup>.</p><p>We will start by illustrating <strong>local identifiability</strong> in which a parameter is known up to <em>finitely many values</em>, and then proceed to determining <strong>global identifiability</strong>, that is, which parameters can be identified <em>uniquely</em>.</p><p>To install <code>StructuralIdentifiability.jl</code>, simply run</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;StructuralIdentifiability&quot;)</code></pre><p>The package has a standalone data structure for ordinary differential equations, but is also compatible with <code>ODESystem</code> type from <code>ModelingToolkit.jl</code>.</p><h2 id="Local-Identifiability"><a class="docs-heading-anchor" href="#Local-Identifiability">Local Identifiability</a><a id="Local-Identifiability-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Identifiability" title="Permalink"></a></h2><h3 id="Input-System"><a class="docs-heading-anchor" href="#Input-System">Input System</a><a id="Input-System-1"></a><a class="docs-heading-anchor-permalink" href="#Input-System" title="Permalink"></a></h3><p>We will consider the following model:</p><p class="math-container">\[\begin{cases}
\frac{d\,x_4}{d\,t} = - \frac{k_5 x_4}{k_6 + x_4},\\
\frac{d\,x_5}{d\,t} = \frac{k_5 x_4}{k_6 + x_4} - \frac{k_7 x_5}{(k_8 + x_5 + x_6)},\\
\frac{d\,x_6}{d\,t} = \frac{k_7 x_5}{(k_8 + x_5 + x_6)} - \frac{k_9  x_6  (k_{10} - x_6) }{k_{10}},\\
\frac{d\,x_7}{d\,t} = \frac{k_9  x_6  (k_{10} - x_6)}{ k_{10}},\\
y_1 = x_4,\\
y_2 = x_5\end{cases}\]</p><p>This model describes the biohydrogenation<sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> process<sup class="footnote-reference"><a id="citeref-2" href="#footnote-2">[2]</a></sup> with unknown initial conditions.</p><h3 id="Using-the-ODESystem-object"><a class="docs-heading-anchor" href="#Using-the-ODESystem-object">Using the <code>ODESystem</code> object</a><a id="Using-the-ODESystem-object-1"></a><a class="docs-heading-anchor-permalink" href="#Using-the-ODESystem-object" title="Permalink"></a></h3><p>To define the ode system in Julia, we use <code>ModelingToolkit.jl</code>.</p><p>We first define the parameters, variables, differential equations and the output equations.</p><pre><code class="language-julia hljs">import StructuralIdentifiability
import ModelingToolkit as MTK

# define parameters and variables
@variables t x4(t) x5(t) x6(t) x7(t) y1(t) y2(t)
@parameters k5 k6 k7 k8 k9 k10
D = Differential(t)

# define equations
eqs = [
    D(x4) ~ -k5 * x4 / (k6 + x4),
    D(x5) ~ k5 * x4 / (k6 + x4) - k7 * x5 / (k8 + x5 + x6),
    D(x6) ~ k7 * x5 / (k8 + x5 + x6) - k9 * x6 * (k10 - x6) / k10,
    D(x7) ~ k9 * x6 * (k10 - x6) / k10
]

# define the output functions (quantities that can be measured)
measured_quantities = [y1 ~ x4, y2 ~ x5]

# define the system
de = MTK.ODESystem(eqs, t, name = :Biohydrogenation)</code></pre><p>After that, we are ready to check the system for local identifiability:</p><pre><code class="language-julia hljs"># query local identifiability
# we pass the ode-system
local_id_all = StructuralIdentifiability.assess_local_identifiability(de, measured_quantities = measured_quantities,
    p = 0.99)
# [ Info: Preproccessing `ModelingToolkit.ODESystem` object
# 6-element Vector{Bool}:
#  1
#  1
#  1
#  1
#  1
#  1</code></pre><p>We can see that all unknowns (except <span>$x_7$</span>) and all parameters are locally identifiable with probability 0.99.</p><p>Let&#39;s try to check specific parameters and their combinations</p><pre><code class="language-julia hljs">to_check = [k5, k7, k10 / k9, k5 + k6]
local_id_some = StructuralIdentifiability.assess_local_identifiability(de, measured_quantities = measured_quantities,
    funcs_to_check = to_check, p = 0.99)
# 4-element Vector{Bool}:
#  1
#  1
#  1
#  1</code></pre><p>Notice that in this case, everything (except the state variable <span>$x_7$</span>) is locally identifiable, including combinations such as <span>$k_{10}/k_9, k_5+k_6$</span></p><h2 id="Global-Identifiability"><a class="docs-heading-anchor" href="#Global-Identifiability">Global Identifiability</a><a id="Global-Identifiability-1"></a><a class="docs-heading-anchor-permalink" href="#Global-Identifiability" title="Permalink"></a></h2><p>In this part tutorial, let us cover an example problem of querying the ODE for globally identifiable parameters.</p><h3 id="Input-System-2"><a class="docs-heading-anchor" href="#Input-System-2">Input System</a><a class="docs-heading-anchor-permalink" href="#Input-System-2" title="Permalink"></a></h3><p>Let us consider the following four-dimensional model with two outputs:</p><p class="math-container">\[\begin{cases}
x_1&#39;(t) = -b  x_1(t) + \frac{1 }{ c + x_4(t)},\\
x_2&#39;(t) = \alpha  x_1(t) - \beta  x_2(t),\\
x_3&#39;(t) = \gamma  x_2(t) - \delta  x_3(t),\\
x_4&#39;(t) = \sigma  x_4(t)  \frac{(\gamma x_2(t) - \delta x_3(t))}{ x_3(t)},\\
y_1(t) = x_1(t) + x_2(t)
y_2(t) = x_2(t)
\end{cases}\]</p><p>We will run a global identifiability check on this enzyme dynamics<sup class="footnote-reference"><a id="citeref-3" href="#footnote-3">[3]</a></sup> model. We will use the default settings: the probability of correctness will be <code>p=0.99</code> and we are interested in identifiability of all possible parameters.</p><p>Global identifiability needs information about local identifiability first, but the function we chose here will take care of that extra step for us.</p><p><strong>Note</strong>: as of writing this tutorial, UTF-symbols such as Greek characters are not supported by one of the project&#39;s dependencies, see <a href="https://github.com/SciML/StructuralIdentifiability.jl/issues/43">this issue</a>.</p><pre><code class="language-julia hljs">import StructuralIdentifiability
import ModelingToolkit as MTK
@parameters b c a beta g delta sigma
@variables t x1(t) x2(t) x3(t) x4(t) y1(t) y2(t)
D = Differential(t)

eqs = [
    D(x1) ~ -b * x1 + 1 / (c + x4),
    D(x2) ~ a * x1 - beta * x2,
    D(x3) ~ g * x2 - delta * x3,
    D(x4) ~ sigma * x4 * (g * x2 - delta * x3) / x3
]

measured_quantities = [y1 ~ x1 + x2, y2 ~ x2]

ode = MTK.ODESystem(eqs, t, name = :GoodwinOsc)

@time global_id = StructuralIdentifiability.assess_identifiability(ode, measured_quantities = measured_quantities)
# 30.672594 seconds (100.97 M allocations: 6.219 GiB, 3.15% gc time, 0.01% compilation time)
# Dict{Num, Symbol} with 7 entries:
#   a     =&gt; :globally
#   b     =&gt; :globally
#   beta  =&gt; :globally
#   c     =&gt; :globally
#   sigma =&gt; :globally
#   g     =&gt; :nonidentifiable
#   delta =&gt; :globally</code></pre><p>We can see that only parameters <code>a, g</code> are unidentifiable, and everything else can be uniquely recovered.</p><p>Let us consider the same system but with two inputs, and we will find out identifiability with probability <code>0.9</code> for parameters <code>c</code> and <code>b</code>:</p><pre><code class="language-julia hljs">import StructuralIdentifiability
import ModelingToolkit as MTK
@parameters b c a beta g delta sigma
@variables t x1(t) x2(t) x3(t) x4(t) y(t) u1(t) [input = true] u2(t) [input = true]
D = Differential(t)

eqs = [
    D(x1) ~ -b * x1 + 1 / (c + x4),
    D(x2) ~ a * x1 - beta * x2 - u1,
    D(x3) ~ g * x2 - delta * x3 + u2,
    D(x4) ~ sigma * x4 * (g * x2 - delta * x3) / x3
]
measured_quantities = [y1 ~ x1 + x2, y2 ~ x2]

# check only 2 parameters
to_check = [b, c]

ode = MTK.ODESystem(eqs, t, name = :GoodwinOsc)

global_id = StructuralIdentifiability.assess_identifiability(ode, measured_quantities = measured_quantities,
    funcs_to_check = to_check, p = 0.9)
# Dict{Num, Symbol} with 2 entries:
#   b =&gt; :globally
#   c =&gt; :globally</code></pre><p>Both parameters <code>b, c</code> are globally identifiable with probability <code>0.9</code> in this case.</p><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><blockquote><p>R. Munoz-Tamayo, L. Puillet, J.B. Daniel, D. Sauvant, O. Martin, M. Taghipoor, P. Blavy <a href="https://doi.org/10.1017/S1751731117002774"><em>Review: To be or not to be an identifiable model. Is this a relevant question in animal science modelling?</em></a>, Animal, Vol 12 (4), 701-712, 2018. The model is the ODE system (3) in Supplementary Material 2, initial conditions are assumed to be unknown.</p></blockquote></li><li class="footnote" id="footnote-2"><a class="tag is-link" href="#citeref-2">2</a><blockquote><p>Moate P.J., Boston R.C., Jenkins T.C. and Lean I.J., <a href="https://doi.org/10.3168/jds.2007-0398"><em>Kinetics of Ruminal Lipolysis of Triacylglycerol and Biohydrogenationof Long-Chain Fatty Acids: New Insights from Old Data</em></a>, Journal of Dairy Science 91, 731–742, 2008</p></blockquote></li><li class="footnote" id="footnote-3"><a class="tag is-link" href="#citeref-3">3</a><blockquote><p>Goodwin, B.C. <a href="https://doi.org/10.1016/0065-2571(65)90067-1"><em>Oscillatory behavior in enzymatic control processes</em></a>, Advances in Enzyme Regulation, Vol 3 (C), 425-437, 1965</p></blockquote></li><li class="footnote" id="footnote-4"><a class="tag is-link" href="#citeref-4">4</a><blockquote><p>Dong, R., Goodbrake, C., Harrington, H. A., &amp; Pogudin, G. <a href="https://arxiv.org/pdf/2111.00991"><em>Computing input-output projections of dynamical models with applications to structural identifiability</em></a>. arXiv preprint arXiv:2111.00991.</p></blockquote></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../ode_types/">« Automatic Uncertainty Quantification, Arbitrary Precision, and Unit Checking in ODE Solutions using Julia&#39;s Type System</a><a class="docs-footer-nextpage" href="../optimization_under_uncertainty/">Optimization Under Uncertainty »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 12 August 2025 11:47">Tuesday 12 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
